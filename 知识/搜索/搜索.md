# 搜索

简介：搜索整个解空间 以得到目标解



注意两者区别

1. **DFS(搜索)**
2. **DFS(图论)**

> 在DFS搜索中，我们强调的是搜索解空间**树**（状态）并非一棵真实的树,注重的是回溯(标记的设置与重置)，也即返回到上一个状态。由于树的特性，它一定不会出现重复访问
>
> 在DFS图论中，我们强调的是访问的是真实的点，因为在**树和图**中无需重复访问重复的结点，所以我们无需重置标记





## 1. DFS策略（回溯思想）

### 零、基础知识

回溯法有“通用的解题法”之称，可以系统地搜索到一个问题的所有解或任一解，它是一个既带有系统性又带有跳跃性的搜索算法。在问题的解空间中，按深度优先搜索策略，从根节点出发搜索解空间树，算法搜索至解空间树的任一节点时，可以使用剪枝函数（约束函数和限界函数）来减去不满足条件的子树和得不到最优解的子树，然后逐层向其祖先节点回溯；否则，进入该子树，继续按深度优先策略。回溯法求问题的所有解时，要回溯到根，且根节点的所有子树都被搜索到才结束。回溯法求问题的一个解时，只要搜索到问题的一个解就可结束。回溯法是解决较为复杂枚举题的一种常用算法。











在**解空间**中**既系统又跳跃**地按**深度优先**的策略从**根节点**开始**搜索**，在过程中可以**剪枝**(用约束函数剪去不满足条件的子树；用限界函数剪去得不到最优解的子树)。 



**解题步骤：**
1.**建立搜索树**（解空间）		（每个节点为一种状态，目标状态只在叶结点上）
2.<u>**写dfs函数**</u>（核心）
3.**给dfs函数赋初值（进入），开始递归搜索解空间**



#### **dfs函数的模板：**

```C++
void dfs(即将要访问的状态的新增参量cur)
{
//不合法状态
    if(cur不合法)
        return;
 //目标状态有两种 
 //①一种是到达第n+1层时，这种不需要在判断里加visited标记。但可能会造成在第n层时多次进入第n+1层，多次输出
 //   if(cur为目标状态)
 //   {
 //       Output();
 //   	return;
 //   }    
  
 //②一种是到达第n层时，这种需要在判断里加标记。一般dfs函数还有参数时用这个
     if(cur为目标状态)
    {
        visited[x][y]=cur;
        Output();
        visited[x][y]=0;    //不要忘，因为这只是解空间树的一个叶子，还要往上回溯
        return;
    } 
   
//合法状态
    if(cur非目标状态且合法)
    {
        标记visited[cur];
        for  
           if dfs(cur+△).... 访问子节点//也可先判，再进
        还原visited标记
    }
    
}
```

**一些理解：** 
1、**dfs函数的工作是访问即将要进入状态（节点）的新增参量cur，并在函数内部递归地访问下一个子状态的新增参量，直至状态（节点）达到了所求状态，。**

2、==dfs函数干的事是： 访问新状态的新增参量 `（比如某数组变量的第cur个位置(int cur)，或者是二维矩阵的一个坐标(x,y)）`因此我们干的事首先是 **访问这个新增参量（枚举可能的值）**。在这之前注意一般还要判断是否进入到了**目标状态（终态）**。其次注意还要**进入下一层**   因此主要有这三步==

==**dfs（cur）是访问第cur层状态的那上面那一个弧。dfs（cur）执行完，第cur层状态就得到了。**==

2、~~注意dfs函数的写法：首先要判断即将进入状态的新参量cur的合法性，①如果不合法就直接退出此次访问。②如果合法且到达了终状态那么就输出之，注意标记visited。③如果合法且未达到终态那就访问所有子节点，且注意标记和取消visited标记以便函数结束回溯到上一个状态时，不会给后续的搜索造成影响    （貌似在进入子节点前就判断合法性，在dfs函数中可以少判断点）~~

3、使用visit或者什么变量（路径）来记录状态是否访问过的 目的 是在递归中需要知道一些变量是否访问过、是否合法(让深度优先搜索不会重复访问节点或skip掉不合法节点)，从而来判断该去做什么

4、 树的节点代表状态，树的边（路径）代表一个解的参量，叶结点代表终状态(dfs函数访问的对象）

6、如果是求最优解，则需要额外创建对应最优变量，在目标状态下，加入变量与对应最优变量的比较过程，搜索进行到底。

7、有的dfs函数在访问cur时，除了cur参数，还带有一些其他参数，比如马踏棋盘中是（x，y，cur）参数。为什么这样做呢？目前看来，马踏飞燕它填充的状态是一个二维数组，而且最重要的是 它是无序填充的，不像n后、01package都是按照下标依次对一维状态数组进行填充(X,X,X,X,X,X)。无序填充意味着，它想寻找下一个参量，进入下一状态时，需要按照一定的规则，不能再像一维数组那样，在马踏棋盘中 参数xy直接决定了子查询的位置！！。

8、当是求最优解或所有解时，就应该遍历整个解空间树。 在找到目标节点时，不要exit，而是使用return 或者什么都不用，在该情况下注意不要忘，这只是解空间树的一个叶子，还要往上回溯。因此也要有visited标记和还原

9、**当函数中不判断不合法情况时，那么就可以直接标记visited了！，需要在上一层进入时判断。**

10、~~写dfs的步骤：先写合法，再写不合法、目标 。~~

11、~~我的习惯是 dfs(cur)访问的是第cur的新增参量，但有时题目给的是从0开始的index，那时我们可以想成，dfs(cur)访问的是 index cur 新增参量，也即位置是cur。~~

~~12、两种模板。都是没有不合法情况了（有也行，就是只需要求一个解的时候，弄一个flag）
①、当参数不仅有cur，还包含下一状态的参量时。可以直接标记。目标状态是cur=n
②、当参数只有cur时，那么目标状态应该是到cur>n~~







关于**子集树**和**排列树**

- 子集树：所给的问题是从n个元素的集合S中找出满足某种性质的子集（每个元素都可以选择要或者不要，也即可以形式化成一个01组），此时的解空间树就是一颗子集树。
  注意：这类子集树一般有$2^n$个叶节点(对应$2^n$个结果)，共有 $2^{n+1}-1$个结点（对应解空间树 ） 
  也即解空间树是**完全的**



- 排列树：所给的问题是n个元素满足某种性质的排列，对应的解空间树就是一颗子集树。
  注意：排列树通常有n!个叶结点
  也即解空间树**不是完全的，一般是越往下，分支越少**





### 一、全排列

>  **输出n个数的全排列**

```C++
#include<bits/stdc++.h>
using namespace std;

void Swap(int &a,int &b)
{
    int t=a;
    a=b;
    b=t;
}

void  Perm(int  list[ ],  int  k,   int m)
{   
    if (k==m)
    {
       for(int i=0; i<m; i++)
         cout <<list[i];
       cout<<endl;
    }
    else
     for(int i=k; i<m; i++)
     {
         Swap(list[k],list[i]);
         Perm(list,  k+1,   m);
         Swap(list[k],list[i]);
     }
}

int main()
{
    int a[]={1,2,3,4,5};
    Perm(a,0,5);
    return 0;
}
```



#### [leetcode46. 全排列](https://leetcode-cn.com/problems/permutations/)

[参考题解](https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/)

```java
class Solution {

    static List<List<Integer>> res = new ArrayList<List<Integer>>();
    public List<List<Integer>> permute(int[] nums) {
    	List<Integer> temp = new ArrayList<Integer>();
    	boolean flag[]=new boolean [nums.length];
    	dfs(0,nums.length,nums,temp,flag);
    	return res;
    }
    //输出一个组数的全排列，
    //cur 和 temp 
    static void dfs(int cur,int len,int[] nums, List<Integer> temp,boolean[] flag ) {
    	if(cur==len) {
    		res.add(new ArrayList<>(temp));//拷贝
    		return;
    	}
    	for(int i=0;i<len;i++) {
    		if(!flag[i]) {
    			temp.add(nums[i]);
    			flag[i]=true;
    			dfs(cur+1, len, nums,temp, flag);
    			flag[i]=false;
    			temp.remove(nums[i]);
    		}
    	}
    }
}
```









下面是老师写的非递归的，不太会  :dog2: 

```C++
#include <iostream>
#include <algorithm>
using namespace std;

int main()
{
    int a[10];
    int t,n;
    cin>>n;

    t=1;
    a[t]=0;
    do
    {
            a[t]=a[t]+1;						//得到子节点
            if(a[t]>n)  						//剪枝——回溯
            {
                a[t]=0;
                t=t-1;
            }
            else
            {
                if (t==n) 						//找到一种排列输出
                {
                     for(int i=1;i<=n;i++)
                     cout<<a[i];
                     putchar(10) ;
                }
                else
                {
                     ++t;
                     a[t]=0;
                } 								//深度优先向下搜索
            }
       } while (t!=0);

    return 0;
}
```







### 二、HorseStepBoard

> **从棋盘的左上角遍历整个n*n的棋盘，共有多少种走法**
> （马走日，且遍历棋盘时，不走走过的路）

<u>**解空间树：  visited[MAXN+1] [MAXN+1]二维数组**</u>

<img src="C:\Users\95266\AppData\Roaming\Typora\typora-user-images\image-20200510162115249.png" alt="image-20200510162115249" style="zoom: 50%;" />



```C++
#include <iostream>
#include <algorithm>
using namespace std;
const int MAXN=50;

int visited[MAXN+1][MAXN+1];//棋盘上每个位置（下标从1开始）都有个bool值，为true代表已经遍历过

int n;			//n*n的棋盘
int ans=0;		//可行解的个数

//判断（x,y）是否在棋盘里
bool isInBoard(int x,int y)
{
    if(x<1 || x>n || y<1 || y>n)
    return false;

    return true;
}

//输出棋盘
void PrinBoard()
{
    for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=n;j++)
            {
                cout<<visited[i][j]<<" ";
            }
            cout<<endl;
        }

    cout<<endl;
}

//dfs的工作是访问新增状态的新增参量 点(x,y) cur步，并递归访问下一个子状态的新增参量
void dfs(int x,int y,int cur)  
{
    //非法情况
    if(!isInBoard(x,y)||visited[x][y])//不合法情况：1、棋盘遍历越界
    return;                            //2、已经遍历过该位置  （注意先判棋盘越界，否则数组会越界）

    //目标状态情况
    if(cur==n*n)
    {
        visited[x][y]=cur;
        PrinBoard();
        ans++;
        visited[x][y]=0;    //不要忘，因为这只是解空间树的一个叶子，还要往上回溯
        return;
    }
//一般情况
//    if(cur>n*n)
//    {
//        Output(解);
//        但由于一个节点的子节点很多，会导致多次输出，因此才用上面的方式 也即dfs函数中只有一个内嵌dfs函数时，用这个，否则会导致多次输出
//    }

    //非目标状态且合法情况
    visited[x][y]=cur;
    cur++;
    dfs(x-2,y+1,cur);//我采取的是 在进入下一层递归后再判断，而不是先判断再进入
    dfs(x-1,y+2,cur);
    dfs(x+1,y+2,cur);
    dfs(x+2,y+1,cur);
    dfs(x+2,y-1,cur);
    dfs(x+1,y-2,cur);
    dfs(x-1,y-2,cur);
    dfs(x-2,y-1,cur);

    visited[x][y]=0;
}


int main()
{
    cin>>n;
    dfs(1,1,1);
    cout<<ans;
    return 0;
}
```







### 三、N_Queens

> **在n*n的棋盘上，放置n个皇后，要求一行、一列、主对角线、副对角线只能有一个皇后，问有多少种摆法,并打印出来**

最朴素的方法我们可以用一个二维数组来记录状态，然后填充，填充完n个未知，在dfs函数的内部，可以直接按行填充。
由于一行一列对角线上都只能有一个，我们可以形式化：用一个一维数组pos[] 来存储位置信息，pos[i]的值value代表第i行上的皇后放在第value列上。因此，解空间变成一维，如下所示

**解空间树：pos一维数组**

<img src="C:\Users\95266\AppData\Roaming\Typora\typora-user-images\image-20200510162643866.png" alt="image-20200510162643866" style="zoom:50%;" />

```C++
#include <iostream>
#include <algorithm>
using namespace std;
const int MAXN=50;//棋盘最大为50*50

//因为n*n棋盘，放n个皇后，每一行，每一列都肯定有皇后
//这里的棋盘是下标从1开始，从左上角开始，建模抽象成填写pos数组
int pos[MAXN]; //pos[i]的值代表的是 在棋盘的i行放置的皇后的列号

bool visitCol[MAXN];  //visit[i]的布尔值代表的是 第i列是否已有皇后
//可以观察到主对角线上的皇后满足x-y=i，同理负对角线上是x+y=i
bool visitZhu[MAXN+MAXN]; //visitZhu[i]的布尔值代表的是 x-y=i 所代表的主对角线\是否已有皇后。
bool visitFu[MAXN+MAXN];   //visitFu[i]的布尔值代表的是 x+y=i 所对标的副对角线/是否已有皇后

int n;//输入n皇后

void PrinBoard()
{
    for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=n;j++)
            {
                if(j==pos[i])
                    cout<<"X ";
                else
                    cout<<"0 ";
            }
            cout<<endl;
        }
        cout<<endl<<endl;
}

// dfs函数的工作是 访问第cur层（也即第cur个新增参量，对应上图括号中的第cur个参量）      并在内部递归地访问子状态
void dfs(int cur)
{
    //不合法的情况 已经在下面的for循环中跳过了

    if(cur>n)//已经递归搜索到n+1层了 结束并输出
    {
        PrinBoard();
    }
    else
    {
        for(int i=1;i<=n;i++)//对第cur层的每一列进行一下枚举
        {
            if(!visitCol[i] && !visitZhu[cur-i+MAXN] && !visitFu[cur+i])
            {
                pos[cur]=i;
                visitCol[i]=true;
                visitZhu[cur-i+MAXN]=true;
                visitFu[cur+i]=true;
                dfs(cur+1);
                pos[cur]=0;
                visitCol[i]=false;
                visitZhu[cur-i+MAXN]=false;
                visitFu[cur+i]=false;
            }
        }
    }
}

int main()
{
    cin>>n;//输入n皇后问题
    dfs(1);//入口
    return 0;
}

```

上题利用了一点二维数组的基本性质：  一条主对角线方向上的元素的两个索引满足 x-y=固定值， 一条副对角线方向的元素的索引满足 x+y=固定值



### 四、01背包

> **尽可能地使背包装的物品的价值最大**

形式化成： 填写一个n维向量  （x1，x2，x3，x4，.... ，xn）   其中 xi只能取0或1代表取或不取

**解空间树：choose一维数组**

<img src="C:\Users\95266\AppData\Roaming\Typora\typora-user-images\image-20200510164250547.png" alt="image-20200510164250547" style="zoom:50%;" />





//待优化 剪枝

```C++
#include <iostream>
#include <algorithm>
#include <string.h>
using namespace std;

const int MAXN=100;

int Weight;             //背包承重量
int StfNum;             //物品的数量
int StfWei[MAXN+1];     //每个物品的重量
int StfPri[MAXN+1];     //每个物品的价值

int Prize;				//dfs中的价值
int MaxPrize;			//最优价值

bool choose[MAXN+1];	//dfs中的选择
bool Maxchoose[MAXN+1];	//最优解

//对第cur个参量的访问
void dfs(int cur)
{
    //目标状态
    if(cur>StfNum)
    {
        if(Prize>MaxPrize)
        {
            MaxPrize=Prize;
            for(int i=1;i<=StfNum;i++)
                Maxchoose[i]=choose[i];
        }
      
    }

    //子情况： 不可以选
    if(StfWei[cur]>Weight)
    {
        choose[cur]=false;
        dfs(cur+1);
        return;
    }

    //子情况1： 可以选  但不选
    choose[cur]=false;
    dfs(cur+1);
    //子情况2： 可以选 所以也选
    choose[cur]=true;
    Weight-=StfWei[cur];
    Prize+=StfPri[cur];
    dfs(cur+1);
    choose[cur]=false;
    Weight+=StfWei[cur];
    Prize-=StfPri[cur];
}

int main()
{
    ios::sync_with_stdio(0);

    cin>>Weight>>StfNum;
    for(int i=1;i<=StfNum;i++)
        cin>>StfWei[i];
    for(int i=1;i<=StfNum;i++)
        cin>>StfPri[i];

    dfs(1);//入口

    cout<<MaxPrize<<endl;
    for(int i=1;i<=StfNum;i++)
            cout<<Maxchoose[i]<<" ";
    return 0;
}
```





### 五、Graph Coloring

> **求使用最少几种颜色能填满图，要求相邻的节点，不能着相同的颜色**

思路是：从小到大，先假设该图能用一种颜色填充完毕，然后就通过dfs函数，来填充该图，若成功填充则证明1种颜色就可以填充完全该图了，若不行就用两种颜色、三种颜色、一遍一遍的试直到可以填充。

**解空间树：flag一维数组**

<img src="C:\Users\95266\AppData\Roaming\Typora\typora-user-images\image-20200803104539471.png" alt="image-20200803104539471" style="zoom: 67%;" />

```C++
#include <iostream>
#include <algorithm>
using namespace std;

const int MAXN=28;

bool Graph[MAXN+1][MAXN+1]; //记录节点的相邻关系
int flag[MAXN+1];           //记录每个节点着什么 颜色   flag[i]=3，代表第i个结点着第三个颜色
bool CanDraw;

int n,m;			//n个结点，m条边（也即2m条弧）
int M;				//填满图需要的颜色数

void CreateGraph()
{
    int temp1,temp2;
    for(int i=1;i<=m;i++)
    {
        cin>>temp1>>temp2;
        Graph[temp1][temp2]=true;
        Graph[temp2][temp2]=true;
    }
}

//第cur个参量(结点)涂上第i个颜色是否可以
bool ok(int cur,int i)
{
    for(int j=1;j<=n;j++)
    {//只需要证明相邻的节点都没涂上i颜色，那么i颜色就是可涂的
        if(Graph[cur][j]==1&&flag[j]==i)
            return false;
    }
    return true;
}


//对新状态的新增参量（第cur个参数的颜色取值）
void dfs(int cur)
{
    //目标状况
    if(cur>n)
    {
        CanDraw=true;
        return;
    }
	//合法的子状况
    for(int i=1;i<=M;i++)
    {
        if(ok(cur,i))
        {
            flag[cur]=i;
            dfs(cur+1);
            flag[cur]=0;
        }
    }

}

void MinColor()
{
    M=1;
    while(1)
    {
        dfs(1);
        if(CanDraw==true)
            return;
        else
            M++;
    }
}

int main()
{
    cin>>n>>m;//n个结点 m条边
    CreateGraph();
    MinColor();
    cout<<M;
    return 0;
}
```











### 六、Dig Landmine

>  题目链接[**lg-2196**](https://www.luogu.com.cn/problem/P2196)     
>  在一个地图上有N个地窖(*N*≤20)，每个地窖中埋有一定数量的地雷。同时，给出地窖之间的连接路径。某人可以从任一处开始挖地雷，然后可以沿着路径往下挖（不能走回头路，也即访问过的不能再访问），当无连接时挖地雷工作结束。设计一个挖地雷的方案，使某人能挖到最多的地雷。

**解空间树：visited数组** 

树枝的多少以及指向是根据节点间是否有路径来确定的，并且终状态的确定是无路可走

<img src="C:\Users\95266\AppData\Roaming\Typora\typora-user-images\image-20210302151247973.png" alt="image-20210302151247973" style="zoom:50%;" />

```C++
#include <iostream>
#include <algorithm>
using namespace std;
const int MAXN=21;

int N;  //地窖的个数

int MineNum[MAXN+1];//MineNum[i] 第i个地窖有地雷的个数
int Graph[MAXN][MAXN];  //Graph[i][j]=1 代表第i个地窖到第j个地窖之间是连通的

int visited[MAXN+1];      //visited[i]的值， 为0代表第i个结点未被访问过，为x代表第i个结点是第x个被访问到的
int Maxvisited[MAXN+1];   //暂记当前状况下最大挖地雷数所对应的路径  最优解

int sum=0;
int Maxsum=0;               //暂记当前状况下，最大的挖雷数


//dfs的工作是访问新状态所新增的参量： 第x地窖 且是第cur个被访问到的     ，
//并在内部递归地访问子状态的新增，直至状态拓展到最终状态
void dfs(int x,int cur)
{
    //没有非法情况，因为在递归子状态的过程中已经判断过了
    visited[x]=cur;	//直接做标记
    sum+=MineNum[x];

    bool flag=false;
    for(int i=1;i<=N;i++)
    {
        if(Graph[x][i]&&!visited[i])
        {
            dfs(i,cur+1);
            flag=true;
        }
    }
    //flag=false 代表该路径走到了头
    if(flag==false)
        if(sum>Maxsum)
        {
            Maxsum=sum;
            for(int i=1;i<=N;i++)
            {
                Maxvisited[i]=visited[i];
            }
        }

    visited[x]=0;   //取消标记
    sum-=MineNum[x];
}


int main()
{
    cin>>N;
    for(int i=1;i<=N;i++)
    {
        cin>>MineNum[i];
    }

    for(int i=1;i<=N;i++)
        for(int j=i+1;j<=N;j++)
        cin>>Graph[i][j];

    for(int i=1;i<=N;i++)
        dfs(i,1);

    for(int i=1;i<=N;i++)
    {
        for(int j=1;j<=N;j++)
            if(Maxvisited[j]==i)
            {
                cout<<j<<" ";
                break;
            }
    }
    cout<<endl<<Maxsum;
    return 0;
}
```









### 七、Sudoku



**解空间树：flag数组** 



```C++
#include<cstdio>
#include<string.h>
#include<algorithm>
using namespace std;

struct point{
    int x,y,num;
    point(int x=0,int y=0,int num=0)
    {
        this->x=x;
        this->y=y;
        this->num=num;
    }
};


char all[10000];
bool row[10][10];//row[i][j]默认值为false,代表第i行 j值没有被填入过   ；  row[i][j]=true，代表第i行 j值已经出现过
bool col[10][10];
bool squ[10][10];// 从左到右从上到下   squ[i][j]=true 代表 第i个正方块 j已经填入
point undoList[82];
int flag[82];          //解空间树的原型数组    flag[i]=4代表第i个没有填入的点填的数字是4 
int undonum;
bool OK;

void Prin()
{
    int j=0;
    for(int i=1;i<=81;i++)
    {
        if(all[i-1]=='.')
            printf("%d",flag[++j]);
        else
            printf("%c",all[i-1]);

    }
    putchar(10);
}

void dfs(int cur)
{
    if(OK)
    return;

    if(cur>undonum)
    {
        OK=true;
        Prin();
        return;
    }
    //第cur个参量在undoList所代表的是什么位置呢？
    int x=undoList[cur].x;
    int y=undoList[cur].y;
    int num=undoList[cur].num;
    for(int i=1;i<=9;i++)
    {
        if((row[x][i]==false)&&(col[y][i]==false)&&(squ[num][i]==false))
        {
            flag[cur]=i;
            row[x][i]=true;col[y][i]=true;squ[num][i]=true;

            dfs(cur+1);

            row[x][i]=false;col[y][i]=false;squ[num][i]=false;
            flag[cur]=0;
        }
    }


}




int main()
{

    while(scanf("%s",all)&&strcmp("end",all)!=0)
    {
//        map<int,int,greater<int>> m; //数字——剩余个数  按照剩余个数降序排列
//        for(int i=1;i<=9;i++)
//            m[9]=i;
        memset(row,0,sizeof(row));
        memset(col,0,sizeof(row));
        memset(squ,0,sizeof(row));
        OK=false;
        undonum=0;
        for(int i=0;i<81;i++)
        {
            int x=i/9+1;         //i值对应的 点的坐标（注意范围是1——9）
            int y=i+1-(x-1)*9;
            int num=((x-1)/3)*3+(y-1)/3+1;// (4,3)->4  (2,9)->3 (5,6)->5  (8,2)->7  (9,6)->8
            if(all[i]=='.')
                undoList[++undonum]=point(x,y,num);// i=0->(1,1); i=1->(1,2);i=9->(2,1);  i=81->(1,1)
            else
            {
                row[x][all[i]-'0']=true;
                col[y][all[i]-'0']=true;
                squ[num][all[i]-'0']=true;
            }

        }
        dfs(1);
    }

    return 0;
}
```



### 八、装载问题

> ​    有n个集装箱要装上2艘载重量分别为C1和C2的轮船。其中集装箱i的重量为Wi，且（W1+W2+….+Wn<=C1+C2）。
>
> ​    装载问题是，是否有一个合理装载方案，可将这n个集装箱都装上这2个轮船，若有，请给出解决方案。

容易证明，如果一个给定装载问题有解，则采用下面的策略可得到最优装载方案。

​    (1)首先将第一艘轮船尽可能装满；

​    (2)将剩余的集装箱装上第二艘轮船。

​    将第一艘轮船尽可能装满等价于选取全体集装箱的一个子集，使该子集中集装箱重量之和最接近C1。由此可知，装载问题等价于特殊的0-1背包问题。 （01背包中 物品的价值等于重量）



**解空间树：x数组的 01填充**

```C++
 void  backtrack( int t ) //搜索子集树中第t层子树
// n是集装箱数，cw是当前载重量，bestw是当前最优载重量，C是第一艘轮船载重量
{ 
     if (t>n)  //到达叶结点
     {  
         if (cw>bestw)   bestw=cw;  //找到一个更好的方案
          return;   
     }
	  if (cw+w[t]<=C)  //搜索左子树
 	 {    
 	     cw+=w[t]; x[t]=1
 	     backtrack( t +1);
 	     cw-=w[t];x[t]=0; //还原到上层结点    
 	  }
	 backtrack( t +1); //搜索右子树           
 }
```

剪枝：

```C++
void  backtrack( int t )
// 引入上界函数cw+r，剪去不含最优解的子树；r是剩余未判定的集装箱重量（初始值为所有集装箱的重量）
{
	if (t>n) {
		if (cw>bestw) bestw=cw; //找到一个更好的方案       
        //bestx[1:n]  x[1:n];    还可以构造最优解
		return;
	}
	r-=w[t];   //进入本层前，先计算剩余未判断的物品重量
	if (cw+w[t]<=C) { //搜索左子树
		cw+=w[t];
		x[t]=1;
		backtrack( t +1);
		cw-=w[t];
        x[t]=0;
	} //还原到上层结点
	if ( cw+r > bestw) { //若余下的重量与已选择的重量之和可以超过前面已得的最优值
		x[t]=0;    //搜索右子树
		backtrack( t +1);
	}
	r+=w[t];  //返回上层前，还要还原剩余载重量和。
}
```



### 九、遍历真实树



### 十、分割子串

用到dp求回文串的知识

```java
public class P0131_分割回文串 {
	static String str="aab";
	static boolean dp[][]=new boolean[str.length()][str.length()];
	public static void main(String[] args) {
		int len=str.length();
		char[] charArray = str.toCharArray();
		for(int i=1;i<=len;i++) {//子串长度
			for(int j=0;j<=len-i;j++) {//起始下标
				int tem=j+i-1;//终点下标
				if(i==1) dp[j][j]=true;
				if(i==2&&charArray[j]==charArray[tem]) dp[j][j+1]=true;
				if(i>2)	dp[j][tem]=(dp[j+1][tem-1])&&(charArray[j]==charArray[tem]);
			}
		}
		dfs(0);
		System.out.println(res);	
	}//main
	static List<List<String>> res = new ArrayList<List<String>>();
	static ArrayList<String> temp = new ArrayList<String>();
	
    static void dfs(int curStart) {
    	//目标状态
    	if(curStart==str.length()) {
    		res.add(new ArrayList<String>(temp));//拷贝 注意堆栈关系
    		return;
    	}
    	
    	//合法状态
    	for(int i=curStart;i<str.length();i++) {
    		if(HuiWen(curStart,i)) {
    			temp.add(str.substring(curStart, i+1));
    			dfs(i+1);
    			temp.remove(temp.size()-1);
    		}
    	}
    }
	/*
	 * 判断一个子串是否是回文，朴素的方法是O(n)
	 * 因此当判断一个字符串中的一些子串是否是回文时，需要O(n^3)
	 * 使用dp思想，dp之后，在判断是否回文就变成O(1)了
	 * 此题需要多次的判断子串是否是回文，因此可以用dp的方法
	 * dp[i][j]=true的含义是i-j代表的子串是否是回文串
	 * 递推公式
	 * - dp[i][i]=true;
	 * - dp[i][i+1]=(arr[i]==arr[i+1])
	 * - dp[i][j]=(dp[i+1][j-1])&&(arr[i]==arr[j])
	 * 
	*/
	static boolean HuiWen(int curStart, int i) {
//		for(int left=curStart,right=i;left<right;left++,right--) {
//			if(str.charAt(left)!=str.charAt(right)) {
//				return false;
//			}
//		}
//		if(dp[curStart][i])
//			return true;
//		return false;
		return dp[curStart][i];
	}
}

```







### 小结

#### 0、最新总结！！！！

两种模板。（寻找一个解的时候，可以单独设置个变量Can）

①、当参数不仅有cur，还包含下一状态的参量时。~~因为包含其他参量（用以确定），因此可以直接标记cur状态，（也可以不标记），。目标状态是cur=n。 第cur步走什么已经确定了，在dfs函数里做的是，用变量访问第cur步，并合法性判断访问下一步。也即先访问填写当前，再判断进入下一个。进入到dfs的一定是合法的参量。也即在dfs确定第cur层填什么，再进入合法的下一层。~~

②、当参数只有cur时，那么目标状态应该是到cur>n。没有其他参量，因此不能直接标记cur状态，要先枚举判断。也即先判断当前，再访问下一个，进入到dfs的不一定是合法参量，也即在dfs判断第cur层填什么，然后再进入不一定合法的下一层。

- **dfs（cur）是访问第cur层状态的那上面那一个弧。dfs（cur）执行完，第cur层状态就得到了。**

二维的情况是 访问第(x,y,cur)





#### 1.马踏棋盘

**解空间树： int visited[MAXN+1] [MAXN+1]二维数组**

visited[x] [y]的值value代表point[x] [y]是第value步走到的

<img src="C:\Users\95266\AppData\Roaming\Typora\typora-user-images\image-20200510162115249.png" alt="image-20200510162115249" style="zoom: 50%;" />
6*6的棋盘为例

细节：若先进行合法性判断，那么可能导致进入不了第n层

```java
public class 马踏棋盘 {
	static int MAXN=50;//棋盘长度最大值
	static int visited[][]=new int [MAXN+1][MAXN+1];
	
	static int n=0;//实际棋盘的长度，需要输入确定
	static int ans=0;//解的个数
	
	static int dir[][]=new int[][]{
		{1,2},
		{2,1},
		{2,-1},
		{1,-2},
		{-1,-2},
		{-2,-1},
		{-2,1},
		{-1,2}
		};
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		n=sc.nextInt();
	    dfs(1,1,1);
	    System.out.println(ans);
	}//main
	
	//解空间是二维数组visited,   cur代表第cur层，cur=n*n时结束
	public static void dfs(int x,int y,int cur) {
		//当前状态不合法
		//当前状态为目标状态
		if(cur==n*n) {
			ans++;
			visited[x][y]=cur;
			prinBoard();
			visited[x][y]=0;
			return;
		}
		//当前状态为中间合法状态
		visited[x][y]=cur;
		for(int i=0;i<8;i++) {
			if(isLegal(x+dir[i][0], y+dir[i][1])&&visited[x+dir[i][0]][y+dir[i][1]]==0)
				dfs(x+dir[i][0], y+dir[i][1], cur+1);
		}
		visited[x][y]=0;
	}
	
	
//	//解空间是二维数组visited,   cur代表第cur层，cur=n*n时结束
//	public static void dfs(int x,int y,int cur) {
//		//当前状态不合法
//		if(!isLegal(x, y)||visited[x][y]!=0) {
//			return;
//		}
//		//当前状态为目标状态
//		if(cur==n*n) {
//			ans++;
//			visited[x][y]=cur;
//			prinBoard();
//			visited[x][y]=0;
//			return;
//		}
//		//当前状态为中间合法状态
//		visited[x][y]=cur;
//		cur++;
//		for(int i=0;i<8;i++)
//			dfs(x+dir[i][0], y+dir[i][1], cur);
//		visited[x][y]=0;
//		
//	}
	
	public static boolean isLegal(int x,int y) {
		if(x<1||x>n||y<1||y>n)
			return false;
		return true;
	}
	public static void prinBoard() {
		System.out.println("第"+ans+"个");
		for (int i =1; i <= n; i++) {
			for (int j = 1; j <= n; j++) {
				System.out.print(visited[i][j]+" ");
			}
			System.out.println();
		}
	}
	
}
```





#### 2.挖地雷

**解空间树：int visit[MAXN] **

  visit[i]=value  第i步走 value地窖

<img src="C:\Users\95266\AppData\Roaming\Typora\typora-user-images\image-20210302151247973.png" alt="image-20210302151247973" style="zoom:50%;" />

```java
public class 挖地雷 {
	public static final int MAXN = 22;//地窖最大值
	
	static int N=0;		//地窖数
	static boolean Graph[][]=new boolean[MAXN+1][MAXN+1];//地窖图
	static int nums[]=new int[MAXN+1];//地窖中的地雷数
	
//	解空间
	static int visit[]=new int[MAXN+1]; //visit[i]=value  代表第i个访问的是value地窖
	static int Maxvisit[]=new int[MAXN+1]; 
	
	static int sum=0;				//已经挖的地雷总数
	static int Maxsum=0;			//挖的最大地雷总数

	static int totalStep=0;
	
	
	public static void main(String[] args) throws IOException {
		N=Reader.nextInt();
		for (int i = 1; i <= N; i++) {
			nums[i]=Reader.nextInt();
		}
		for(int i=1 ; i<=N-1;i++) {
			for(int j=i+1;j<=N;j++) {
				Graph[i][j]=Reader.nextInt()==1? true:false;
			}
		}

		for (int i = 1; i <= N; i++) {
			dfs(1,i);
		}
//		System.out.println("总共走了"+totalStep+"步");
		for (int i = 1; i < totalStep; i++) {
			System.out.print(Maxvisit[i]+" ");
		}
		System.out.println(Maxvisit[totalStep]);
		System.out.println(Maxsum);
		
		
	}//main
	
	//dfs的工作是访问新状态的新增参量：即在第cur步，走第x地窖
	//visit (X,X,X,X,X)  visit[i]=value  第i步走 value地窖
	public static void dfs(int cur,int x) {
		//不合法情况
		//判断是否可走
		boolean flag=false;
		visit[cur]=x;
		for(int i=1;i<=N;i++) {
			if(isLegal(cur+1,i)) {
				flag=true;
				break;
			}
		}
		//目标情况:无路可走
		if(flag==false) {
			visit[cur]=x;
			sum+=nums[x];
			if(sum>Maxsum)
			{
				Maxsum=sum;
				totalStep=cur;
				System.arraycopy(visit, 1, Maxvisit, 1, cur);
			}
			visit[cur]=0;
			sum-=nums[x];
			return;
		}
		
		//合法情况
		visit[cur]=x;
		sum+=nums[x];
		for(int i=1;i<=N;i++) {
			if(isLegal(cur+1,i))
				dfs(cur+1, i);
		}
		visit[cur]=0;
		sum-=nums[x];
	}
	//判断在第step步，走i地窖是否可行
	//地窖没被走过&&地窖是连通的
	static boolean isLegal(int step,int i) {
		//是否连接
		if(!Graph[visit[step-1]][i])
			return false;
		for(int j=1;j<=step-1;j++) {
			if(visit[j]==i)
				return false;
		}
		return true;
	}
}
```







#### 1.  01背包

**解空间树 int choose[ ]**

choose[i]=1 代表第i个物品选上， choose[i]=0代表第i个物品不选

<img src="C:\Users\95266\AppData\Roaming\Typora\typora-user-images\image-20200510164250547.png" alt="image-20200510164250547" style="zoom:50%;" />
4个物品为例

```java
//此题为寻找最优解，因此到达目标状态后要回溯，直到遍历所有解，
//也因此需要设置一个变量和最优变量来记录

//解空间是 (X,X,X,X,X,X,X) 
public class _01背包 {
	
	public static final int MAXN = 100;//物品的最大值
	
	static int Weight=0;//背包的承重
	static int StfNum=0;//物品的总数量
	static int StfWit[]=new int[MAXN+1];//每个物品的重量
	static int StfPrz[]=new int[MAXN+1];//每个物品的价值
	
	static int totalPrize=0;
	static int choose[]=new int[MAXN+1];
	static int MaxtotalPrize=0;
	static int Maxchoose[]=new int[MAXN+1];
	
	//访问新状态的第cur个新增参量
	public static void dfs(int cur) {
		//不合法状态
		//目标状态
		if(cur>StfNum) {
			if(totalPrize>MaxtotalPrize)
			{
				MaxtotalPrize=totalPrize;
				System.arraycopy(choose, 1, Maxchoose, 1, StfNum);
			}
			return;
		}
		//合法状态
		if(Weight>=StfWit[cur])
		{
			choose[cur]=1;//选该物品
			totalPrize+=StfPrz[cur];
			Weight-=StfWit[cur];
			dfs(cur+1);
			choose[cur]=0;
			totalPrize-=StfPrz[cur];
			Weight+=StfWit[cur];
			
			dfs(cur+1);//不选
			
		}
		else {//不能选
			dfs(cur+1);
		}
		
		
	}
	
	public static void main(String[] args) throws IOException {
		Weight = Reader.nextInt();
		StfNum = Reader.nextInt();
		
		for (int i = 1; i <= StfNum; i++) {
			StfWit[i]=Reader.nextInt();
		}
		for (int i = 1; i <= StfNum; i++) {
			StfPrz[i]=Reader.nextInt();
		}
		
		dfs(1);
		System.out.println(MaxtotalPrize);
		for (int i = 1; i <= StfNum; i++) {
			System.out.print(Maxchoose[i]+" ");
		}
	}//main
}
```

#### 2.N皇后

**解空间树：int pos[]**

记录n皇后的位置,pos[i]=value 代表第i行的第value列放上皇后

<img src="C:\Users\95266\AppData\Roaming\Typora\typora-user-images\image-20200510162643866.png" alt="image-20200510162643866" style="zoom: 33%;" />

```java
public class NQueen {
	public static final int MAXN = 50;//棋盘最大值
	static int n=0;//棋盘大小，动态输入的
	static int []pos=new int[MAXN+1];//记录n皇后的位置
	static int ans=0;
	
	//辅助变量
	static boolean visitedCol[]=new boolean[MAXN+MAXN+1];
	static boolean visitedZhu[]=new boolean[MAXN+MAXN+1];
	static boolean visitedFu[]=new boolean[MAXN+MAXN+1];
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		n=sc.nextInt();
		dfs(1);
		System.out.println("共有"+ans+"种");

	}//main
	//访问新状态的 新增参量，也即访问pos的第cur个位置
	public static void dfs(int cur) {
		//不合法情况
		
		//目标状态(若是第n个位置是最终新增的话，会在此步多很多,来判断哪一列为空，因此把第n+1个位置作为最终)
		if(cur>n) {
			PrinBoard();
			ans++;
			return;
		}
		
		//非目标状态,设置本层,进入下一层
		for (int i = 1; i <= n; i++) {
			if(!visitedCol[i]&&!visitedZhu[cur-i+MAXN]&&!visitedFu[cur+i]) {
				pos[cur]=i;
				visitedCol[i]=true;
				visitedZhu[i]=true;
				visitedFu[i]=true;
				dfs(cur+1);
				pos[cur]=0;
				visitedCol[i]=false;
				visitedZhu[i]=false;
				visitedFu[i]=false;
			}
			
		}
	}
	private static void PrinBoard() {
		System.out.println("第"+ans+"种");
		for(int i=1;i<=n;i++) {
			for(int j=1;j<=n;j++) {
				if(pos[i]==j)
					System.out.print("X ");
				else
					System.out.print("O ");
			}
			System.out.println();
		}
		
	}
}
```







<img src="C:\Users\95266\AppData\Roaming\Typora\typora-user-images\image-20210320092412251.png" alt="image-20210320092412251" style="zoom:50%;" />

```java
public class n皇后 {
	public static final int MAXN = 20;
	static int n;
	static int s;
	static char g[][]=new char[MAXN][MAXN];
	static boolean row[]=new boolean[MAXN];
	static boolean col[]=new boolean[MAXN];
	static boolean mdg[]=new boolean[MAXN+MAXN];
	static boolean udg[]=new boolean[MAXN+MAXN];
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		n=sc.nextInt();
		init();
		dfs(1, 1, 1);
	}//main
	
	static void init() {
		Arrays.fill(row, false);
		Arrays.fill(col, false);
		Arrays.fill(mdg, false);
		Arrays.fill(udg, false);
		for(int i=0;i<MAXN;i++) {
			for(int j=0;j<MAXN;j++) {
				g[i][j]='.';
			}
		}
		s=0;
	}

	//解空间是填写一个二维数组g[][]，类似二叉树 第cur步访问第(x,y)
	static void dfs(int x,int y,int cur) {
		//目标状态
		if(cur>n*n) {
			if(s==n) {
				for(int i=1;i<=n;i++) {
					for(int j=1;j<=n;j++)
						System.out.print(g[i][j]);
					System.out.println();
				}
				System.out.println();
			}
			return;
		}
		
		//合法状态
		int nextx=x,nexty=y;
		if(nexty==n) {
			nexty=1; nextx++;
		}
		else nexty++;
		
		//1选第cur个位置(x,y)作为皇后
		if(!row[x]&&!col[y]&&!mdg[y-x+MAXN]&&!udg[x+y]) {
			s++;g[x][y]='Q';row[x]=true;col[y]=true; mdg[y-x+MAXN]=true; udg[x+y]=true;
			dfs(nextx, nexty, cur+1);
			s--;g[x][y]='.';row[x]=false;col[y]=false; mdg[y-x+MAXN]=false; udg[x+y]=false;
		}
		
		//2不选第cur个位置(x,y)作为皇后
		dfs(nextx, nexty, cur+1);	
	}			
}//class
```











#### 3.图着色问题

**解空间树：int flag[]**

flag[i]=value 代表 第i个结点上涂上第value色

<img src="C:\Users\95266\AppData\Roaming\Typora\typora-user-images\image-20200803104539471.png" alt="image-20200803104539471" style="zoom: 67%;" />

```java

//给定一个图(由节点组成),然后判断能用几种颜色把它填满(相邻的区域不能一样的颜色)
public class 图着色问题 {


	public static final int MAXN = 30;//图的最大节点数
	
	static boolean Graph[][]=new boolean[MAXN+1][MAXN+1];
	static int flag[]=new int[MAXN+1];//flag[i]的值value 代表第i个结点涂的是第value色
	static boolean CanDraw=false;
	
	static int n,m;//n个结点 m条边
	static int Min;
	
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		//n个结点 m条边
		n=sc.nextInt();
		m=sc.nextInt();
		CreateGraph();
		MinColor();
		System.out.println(Min);

	}//main
	
	static void CreateGraph() {
		Scanner sc = new Scanner(System.in);
		for (int i = 0; i < m; i++) {
			int temp1=sc.nextInt();
			int temp2=sc.nextInt();
			Graph[temp1][temp2]=true;
			Graph[temp2][temp1]=true;
		}
	}
	static void MinColor() {
		Min=0;
		while(!CanDraw) {
			Min++;
			dfs(1);
		}
	}
	
	//对flag[1-n] 访问
	static void dfs(int cur) {
		//不合法情况，找到一种就直接退出
		if(CanDraw)
			return;
		
		//目标情况
		if(cur>n) {
			CanDraw=true;
			return;
		}
		
		//合法情况
		for(int i=1;i<=Min;i++) {
			if(isLegal(cur,i)) {
				flag[cur]=i;
				dfs(cur+1);
				flag[cur]=0;
			}
		}
	}
	//第cur个结点，着i色可以吗？
	static boolean isLegal(int cur, int i) {
		for(int j=1;j<=n;j++) {
			if(Graph[cur][j]==true&&flag[j]==i)
				return false;
		}
		return true;
	}
	
	
}
```









---

## 2. BFS策略

### 零、基础知识

广度优先搜索（也称宽度优先搜索，BFS）是连通图的一种遍历策略。它的思想是从一个顶点V0开始，**辐射状**地优先遍历其周围较广的区域。 很多最短路径算法就是基于广度优先的思想成立的。



模板：

```C++
void bfs()
{
    queue <E> Q;
    
	visited[start]=true;
	Q.push(start);
    
	while(!Q.empty())
	{
        temp=Q.front();
        Q.pop();

        if(temp为目标状态)
        {    
            输出
            return;
        }
        
        for(扩展所有子节点)
        {
            if(合法)
            {
                visited;
                然后push子节点;
            }   
        }
    
	}//while
}

```

理解：

1. 头visit标记	->	头进队	->	**队头弹	->	访问	->	for子合法判断	->	子visited标记	->	子进队**        ->END
   加深部分为循环过程；
2. 结束循环有两个方式： 1、找到目标； 2、队列空了（说明BFS遍历完全了）
3. 顺序是：  ==**先visited标记 再进队 再出队访问**==，可以防止重复进队的情况



### 一、Maze

一个5×5的迷宫

```C++
#include <iostream>
#include <algorithm>
#include <queue>
#include <cstdio>
using namespace std;
const int MAXN=28;
int Graph[MAXN][MAXN];          //存储地图 0代表可以走，1代表是墙
int visited[MAXN][MAXN];        //为1代表该点已经走过
struct Node         
{
    int x,y,step;
    bool operator==(Node w)
    {
        if(this->x==w.x&&this->y==w.y)
            return true;
        return false;
    }
};
Node start;
Node des;  
Node pre[MAXN][MAXN]; //pre[x][y]的值，代表(x,y)所在的位置的前一个节点    用于输出路径

int dir[][2] = {
		{0, 1}, {1, 0},
		{0, -1}, {-1, 0}
};

bool isValid(Node w)
{
    if(Graph[w.x][w.y]==1||w.x<1||w.x>5||w.y<1||w.y>5)
        return false;
    return true;
}

bool bfs()
{
    queue<Node> Q;
    
    visited[start.x][start.y] = true;
    start.step = 0;
    Q.push(start);

    while(!Q.empty())
    {
        Node temp1=Q.front();
        Q.pop();
        if(temp1==des)
        {
            des.step=temp1.step;
            return true;
        }

        Node temp2;
        for(int i=0;i<4;i++)
        {
            temp2.x=temp1.x+dir[i][0];temp2.y=temp1.y+dir[i][1];

            if(isValid(temp2)&&!visited[temp2.x][temp2.y])//不超过棋盘范围+非墙+且未入队
            {
                visited[temp2.x][temp2.y]=1;
                temp2.step=temp1.step+1;
                pre[temp2.x][temp2.y]=temp1;
                Q.push(temp2);
            }
        }
    }//while

    return false;
}


void PrinRoute(Node w)
{
    if(w==start)
    {
        printf("(1, 1)\n");
        return;
    }
    else
        PrinRoute(pre[w.x][w.y]);

    printf("(%d, %d)\n",w.x,w.y);
}

int main()
{
    for(int i=1;i<=5;i++)
        for(int j=1;j<=5;j++)
    {
        cin>>Graph[i][j];
    }
    start.x=1;start.y=1;
    des.x=5;des.y=1;
    if(bfs())
    {
        cout<<"该迷宫可解"<<endl;
        cout<<"需要"<<des.step<<"步"<<endl;
        cout<<"路径是："<<endl;
        PrinRoute(des);
    }
    else
    {
        cout<<"该迷宫没有解";
    }
    return 0;
}
```



### 二、Ignatius and the Princess I

[链接HDU-1026](https://vjudge.net/problem/HDU-1026)

> 给定一个N*M的矩阵 （由数字、'.'、‘X’）。问从（0,0）到（N，M）的最短时间
>
> 规则：
> 1.'X' is trap， you can‘t walk on it.
> 2.',' is nothing, you can walk on it.
> 3.nubmer stands for a monster, you have to spend number time to kill it 
> 4.a step needs a time 



[参考的题解](https://blog.csdn.net/mengxiang000000/article/details/50541649?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase)

思路：这题是BFS，但是搜索树和队列不同于往常。我们都知道，BFS有贪心的特性，也可以说BFS有路径优先的特性，但是我们这里要的是时间优先，并不是路径优先，所以呢，我们这里就要应用优先队列改变优先条件，让我们控制的不再是路径优先，变成了时间优先就行了。（搜索树的每一层代表一个时间，从上到下时间依次增加）

```C++
#include<bits/stdc++.h>
using namespace std;
#define INF 0x3f3f3f3f//1,061,109,567

typedef long long ll;//9*10^18
typedef unsigned long long ull;
int N,M;
char a[105][105];
bool visited[1005][1005];
int fx[]={0,1,0,-1};
int fy[]={1,0,-1,0};

struct node{
    int x,y;
    int time;
    int luxian[2][1005];        //到达 (x,y)点 的路线:   time秒所在的点 x=luxian[0][time]   y=luxian[1][time]

}now,nex;

bool operator <(const node x,const node y)
{
    if(y.time<x.time)
        return true;
    return false;
}

bool isValid(int x,int y)
{
    if(x<0||y<0||x>=N||y>=M||visited[x][y]||a[x][y]=='X')
        return false;
    return true;

}
void Prin()
{
    printf("It takes %d seconds to reach the target position, let me show you the way.\n",now.time);
    for(int i=1;i<=now.time;i++)
    {
        if(now.luxian[0][i]==0&&now.luxian[1][i]==0)
        {
            int idx;
            for(idx=i;now.luxian[0][idx]==0&&now.luxian[1][idx]==0;idx++) ;
            printf("%ds:(%d,%d)->(%d,%d)\n",i,now.luxian[0][i-1],now.luxian[1][i-1],now.luxian[0][idx],now.luxian[1][idx]);
            i++;
            for(;i<=idx;i++)
            {
                 printf("%ds:FIGHT AT (%d,%d)\n",i,now.luxian[0][idx],now.luxian[1][idx]);
            }
            i--;
        }
        else
        printf("%ds:(%d,%d)->(%d,%d)\n",i,now.luxian[0][i-1],now.luxian[1][i-1],now.luxian[0][i],now.luxian[1][i]);


    }
    printf("FINISH\n");

}

void bfs()
{
    memset(visited,0,sizeof(visited));
    memset(now.luxian,0,sizeof(now.luxian));
    memset(nex.luxian,0,sizeof(nex.luxian));
    priority_queue<node> Q;
    now.x=0,now.y=0,now.time=0;
    now.luxian[0][0]=0,now.luxian[1][0]=0;      // 0秒 时 所在的位置为 （0,0）
    visited[0][0]=true;
    Q.push(now);

    while(!Q.empty())
    {
        now=Q.top();
        Q.pop();

        if(now.x==N-1&&now.y==M-1)
        {
            Prin();
            return;
        }

        for(int i=0;i<4;i++)
        {
            nex=now;
            nex.x=now.x+fx[i],nex.y=now.y+fy[i];
            if(isValid(nex.x,nex.y))
            {
                visited[nex.x][nex.y]=true;
                if(a[nex.x][nex.y]=='.')
                {
                    nex.time++;
                    nex.luxian[0][nex.time]=nex.x,nex.luxian[1][nex.time]=nex.y;
                    Q.push(nex);
                }
                else{
                        nex.time=nex.time+a[nex.x][nex.y]-'0'+1; //n用来杀怪兽 1用来跑路
                        nex.luxian[0][nex.time]=nex.x,nex.luxian[1][nex.time]=nex.y;
                        Q.push(nex);
                }
                
            }
        }

    }
    //访问完了说明没找着路径
    printf("God please help our poor hero.\nFINISH\n");
}

int main()
{
    while(~scanf("%d %d",&N,&M))
    {
        for(int i=0;i<N;i++)
            scanf("%s",a[i]);
        bfs();
    }
    return 0;
}
```



### 三、层序遍历

[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ret = new ArrayList<List<Integer>>();
        if (root == null) {
            return ret;
        }

        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            List<Integer> level = new ArrayList<Integer>();//只能这样，而不能在外边创建，然后clear
            int currentLevelSize = queue.size();
            for (int i = 1; i <= currentLevelSize; ++i) {
                TreeNode node = queue.poll();
                level.add(node.val);
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
            ret.add(level);//add的参数 是引用传递，因此需要上面的new ，而如果只使用一个level 然后clear，到最后 ret中栈内存指向堆中同一个level！
        }
        
        return ret;
    }
}

```

### 四、八数码

[acwing八数码](https://www.acwing.com/problem/content/847/)

```java
class state{
	String str=null;
	int step=0;
	public state(String str, int step) {
		super();
		this.str = str;
		this.step = step;
	}
}

public class 八数码 {

	static int dir[][]= {
			{0,1},
			{1,0},
			{0,-1},
			{-1,0},
	};
	
	
	static HashSet<String> hs = new HashSet<String>();
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		String nextLine = sc.nextLine();
		String start = nextLine.replace(" ", "");
		
		LinkedList<state> queue = new LinkedList<state>();
		state startState = new state(start, 0);
		//bfs
		hs.add(start);
		queue.offer(new state(start, 0));
		
		while(!queue.isEmpty()) {
			state poll = queue.poll();
			String str = poll.str;
			int step = poll.step;
			
			if(str.equals("12345678x")) {
				System.out.println(step);
				return;
			}
			
			//获取子状态String
			int index = str.indexOf('x');
			int x=index/3;//x的一维位置->二维
			int y=index%3;
			for(int i=0;i<4;i++) {
				int newx=x+dir[i][0];//新位置的二维坐标
				int newy=y+dir[i][1];
				
				if(isLegal(newx,newy)) {
					int newIndex=newx*3+newy;//新位置的一维坐标
					
					char[] charArray = str.toCharArray();//得到新状态的字符串
					char temp=charArray[newIndex];
					charArray[newIndex]=charArray[index];
					charArray[index]=temp;
					String newstr=new String(charArray);//得到新状态的字符串
					state newState=new state(newstr, step+1);//得到新状态!!!!!
					if(!hs.contains(newstr)) {
						hs.add(newstr);
						queue.offer(newState);
					}
				}
			}
			
		}
		System.out.println(-1);
	}//main
	private static boolean isLegal(int newx, int newy) {
		if(newx<0||newx>=3||newy<0||newy>=3)
			return false;
		return true;
	}
}

```



---

### 五、Maze+字典序

输出所有最短路径中，字典序最小的那一个路径

```java
package lanqiao.year2019_10th;

public class E迷宫 {
	public static final int MAXN = 60;

	static int g[][] = new int[MAXN][MAXN];
	static int dist[][] = new int[MAXN][MAXN];
	static int n = 30, m = 50;
	static int dirx[] = { 1, 0, 0, -1 };// 下左右上
	static int diry[] = { 0, -1, 1, 0 };
	static Character dirc[] = { 'D', 'L', 'R', 'U' };

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		for (int i = 1; i <= n; i++) {
			String str = sc.next();
			char[] charArray = str.toCharArray();
			for (int j = 1; j <= m; j++) {
				g[i][j] = charArray[j - 1] - '0';// 很tm容易错的一步！，老是忘了-'0'
			}
		}

		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= m; j++) {
				dist[i][j] = -1;
			}
		}
		// bfs
		point start = new point(1, 1);
		point end = new point(n, m);

		LinkedList<point> queue = new LinkedList<point>();
		dist[n][m] = 0;
		queue.offer(new point(n, m));
		while (!queue.isEmpty()) {
			point poll = queue.poll();
			int x = poll.x;
			int y = poll.y;
			if (poll.equals(start)) {
				break;
			}
			for (int i = 0; i < 4; i++) {
				int nextx = x + dirx[i];
				int nexty = y + diry[i];
				if (nextx >= 1 && nextx <= 30 && nexty >= 1 && nexty <= 50 && dist[nextx][nexty] == -1
						&& g[nextx][nexty] == 0) {
					dist[nextx][nexty] = dist[x][y] + 1;
					queue.offer(new point(nextx, nexty));
				}
			}
		}
//		dfs(1,1);
		// 也可以这样
		int x = 1, y = 1;
		while (!(x == 30 && y == 50)) {
			for (int i = 0; i < 4; i++) {
				int nextx = x + dirx[i];
				int nexty = y + diry[i];
				if (nextx >= 1 && nextx <= 30 && nexty >= 1 && nexty <= 50 && dist[nextx][nexty] == dist[x][y] - 1) {
					x = nextx;
					y = nexty;
					path.add(dirc[i]);
					break;
				}
			}
		}
		path.forEach(c -> System.out.print(c));
	}// main

	
	static boolean st[][] = new boolean[MAXN][MAXN];
	static ArrayList<Character> path = new ArrayList<>();

	private static void dfs(int x, int y) {
		if (x == 30 && y == 50) {
			System.out.println("I got it!");
			return;
		}
		st[x][y] = true;
		for (int i = 0; i < 4; i++) {
			int nextx = x + dirx[i];
			int nexty = y + diry[i];
			if (nextx >= 1 && nextx <= 30 && nexty >= 1 && nexty <= 50 && dist[nextx][nexty] == dist[x][y] - 1
					&& !st[nextx][nexty]) {
				path.add(dirc[i]);
				dfs(nextx, nexty);
				break;
			}
		}

	}

}

```





## 3. DFS/BFS异同

#### 相同点：

1. DFS和BFS都可以认为有个解空间树，一个是深度，一个是层序。





#### 不同点：

1. DFS可以不重不漏的枚举所有的可以到达目标状态的路径。
2. BFS效率更高，适用于找一条最快到达目标状态的路径。
3. BFS不用回溯（也即不用使用递归函数，不用visited先标记再取消），是在顺序执行的过程中找到最优解   
4. 在BFS中 通常用队列作为访问树的工具



DFS更适合得到所有的解，而BFS得到一个最优解（因为它是由近到远 辐射寻找最优答案）









- DP问题和最短路问题互通，DP问题是特殊的最短路问题，最短路问题包含DP问题。DP问题时间复杂度低

- 记忆化搜索是深搜

- 当边的权重都一样的时候，才可以用BFS求最短路



### **分支限界法与回溯法的区别：**

（1）求解目标不同：回溯法的求解目标是找出解空间树中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出在某种意义下的最优解。

（2）搜索方式的不同：回溯法以深度优先的方式搜索解空间树，而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树。





- 分支限界法则以广度优先或以最小耗费优先的方式呈辐射状地搜索解空间树。

- 在分支限界法中，每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被加入活结点表中。
- 此后，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所需的解或活结点表为空时为止。



## 4. DFS与回溯

这俩名词的关系是啥我也不太清楚

以下摘自百度

回溯搜索是深度优先搜索（DFS）的一种
对于某一个搜索树来说（搜索树是起记录路径和状态判断的作用），回溯和DFS，其主要的区别是，回溯法在求解过程中不保留完整的树结构，而深度优先搜索则记下完整的搜索树。
为了减少存储空间，在深度优先搜索中，用标志的方法记录访问过的状态，这种处理方法使得深度优先搜索法与回溯法没什么区别了。





## 5. 扩展：DLX

舞蹈链