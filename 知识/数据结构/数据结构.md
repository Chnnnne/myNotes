# 数据结构





## 查找

查找(Searching) 根据给定的某个值，在查找表中确定一个其关键字(key)等于给定值的记录或数据元素。若表中存在这样的一个记录，则称查找是成功的，否则则是不成功的。





### 哈希算法

> 背景：
> （举例：在数组a[100]中，查询是否有358这个数字）在查找的过程中，时间主要用于关键字值间的比较（比如暴力查找，逐个遍历O(n)。二分查找（nlogn+logn）。那么大胆一点，可不可以不经过关键字值间的比较就找到记录所在的位置呢？
> 答案是可以的：若能在待查记录的**关键字值**和它的**存储位置**之间建立一个**对应关系**则查找时不必再进行关键字值间的比较了！

~~哈希函数 H(key)=address   	（这里的address 不一定是内存地址，而可以是数组大的下标）理想的哈希函数是 关键字值和 地址一一对应的，但是这一般是做不到的，~~

~~哈希表（散列表）   采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表（Hash table）~~

根据设定的**哈希函数**及**处理冲突的方法**将查找表中各数据元素存储在一段有限的连续空间中，即得哈希表
哈希表（Hash table，也叫散列表），~~是根据关键码值(Key value)~~而直接进行访问的数据结构

哈希函数的作用：值 -> 可能冲突的address

哈希冲突处理函数的作用：冲突的adress -> newAddress

#### 一、构造哈希函数的基本方法：

1. 直接定址法	 H(key)=a×key+b   
2. 数字分析法
3. 折叠法
4. 除留余数法   H(key)=key%p      
   注意对p加以限制：**p为质数**，因为若p为非质数会发生（n*公因子）%(k *公因子)=公因子 *（n%k）也即会出现所有含公因子的关键字都映射到公因子倍数的哈希地址上



#### 二、处理冲突的基本方法：

处理冲突是指对于一个**待插入哈希表的数据元素**，若按给定的**哈希函数**求得的**哈希地址**已被占用，则按一定**规则**（对哈希地址再用函数Hi处理）求**下一哈希地址**(或者直接放在同一位置上用链子连接起来)，如此重复，直至找到一个可用的地址以保存该元素

1. 开放定址法
   $H_i$  =  ( H(key) + $d_i$ ) %m         其中H(key) ，m为哈希表长，$d_i$为增量序列
   若$d_i$=1,2,3 ... m-1 则称 线性探测再散列
   若$d_i=1^2，-1^2,2^2，-2^2 $...  则称二次探测再散列

<img src="C:\Users\95266\AppData\Roaming\Typora\typora-user-images\image-20200509152456144.png" alt="image-20200509152456144" style="zoom: 67%;" />

<img src="C:\Users\95266\AppData\Roaming\Typora\typora-user-images\image-20200509152505269.png" alt="image-20200509152505269" style="zoom: 67%;" />





2. 链地址法
   将所有按给定的哈希函数求得的哈希地址相同的关键字存储在同一线性链表中，且使链表按关键字有序
   <img src="C:\Users\95266\AppData\Roaming\Typora\typora-user-images\image-20200509153538732.png" alt="image-20200509153538732" style="zoom:67%;" />





3. 公共溢出区法







#### 三、在哈希表中查找元素

**过程：**
在哈希表中查找数据元素的过程与将数据元素插入哈希表的过程基本一致，即：

- 根据待关键字key, 按给定的Hash函数 ，求哈希地址
- 若该地址上无数据元素，则查找失败；
- 若该地址上有数据元素，则比较key；
  - 若相等，则成功，
  - 若不等，则按冲突处理方法求下一可能的存储地址



虽然哈希表在关键字值与存储位置间建立了影响，但由于冲突的存在，查找时仍需进行关键字的比较(相比暴力比较已经少了很多很多了)，因此仍以 查找成功时的平均查找长度 和查找不成功时的比较次数 作为衡量查找效率的依据。



#### 总的过程是：

1、构造哈希表：
先已知一个普通的数组，然后根据特点构造哈希函数(直接定址法/除留余数法)，然后根据哈希函数和处理冲突(开放定址法/链地址法)的方法把普通的数组映射成哈希表。
2、查数据： 
根据哈希函数和冲突处理在哈希表中查给定的某个数据是否存在（中间可能有数次的比较过程）







# 栈和队列



1、

队列是FIFO ，也即从尾巴进入，从头出来

数组模拟队列

```java
int q[];
int tt=-1,hh=0;//tt始终指向队尾元素，hh始终指向队头元素

//入队操作
q[++tt]=a;
//出队操作
a=q[hh++];
//判空操作
if(tt+1==hh){
    queue is empty;
}
```











# 树与图





## 一、树

### 0、基础知识

树由结点组成，且仅有一个根节点。

- 结点拥有子树数成为度
- 结点可分为(叶子结点)终端结点和(分支结点)非终端结点
- 树有层次，**根节点所在的层是第一层**，而非第零层。树的最大层次称为深度。





### 1、 二叉树

二叉树的特点是每个结点最多有两个子树

- 满二叉树：不缺叶子，是百分之百满的。满二叉树一定是完全二叉树
- 完全二叉树： 和满二叉树序号相同的

完全二叉树从1开始的话，那么对于 i 节点，2i为其左孩子，2i+1为其右孩子, i/2为其父节点

 (i << 1) (i << 1 | 1) 						 (i >> 1)



#### **二叉树的性质**

1. 第i层最多有 $2^{i-1}$个结点    （根节点为第一层）
2. 深度为k的二叉树最多有$2^k-1$ 个结点
3. 二叉树结点总数$n=n_0+n_1+n_2  (下标代表度，也即度为0的结点是叶子结点)$ 
4. **如果一棵树有 N 个节点，则这棵树有 N-1 条边。**$n=B+1$
5. $B=n_1+2n_2$ 也即分支数等于度为1的结点射出来的和度为2的结点射出来的
6. 综合3、4 、5得，**$n_0=n_2+1$**
7. 具有n个结点的完全二叉树   深度为$\lfloor log_2n\rfloor +1$。 

#### **二叉树的遍历**

1、**先序遍历**

遍历的顺序是：先根节点，再左子树，再右子树(递归访问)。对子树的访问也是先序遍历。

（1） 

2、**中序遍历**



3、**后序遍历**

```java
package algorithm.数据结构;

import java.util.Scanner;

public class BiTree {
	public static void main(String[] args) {
		BiTree root = null;
		root=PreCreateBiTree(root);
		PostOrderTraverse(root);
	}//main
	

	int value;
	BiTree lchild=null;
	BiTree rchild=null;
	
	public BiTree() {
	}
	//从任意结点开始，先创根节点，再创左子树、右子树
	public static BiTree PreCreateBiTree(BiTree T) {
		//此代码原本有bug 
		//幻想的是传入root(初值为null，然后赋值形参，从而root指向一个对象)
		//注意堆栈关系！！
		//返回根节点
		System.out.println("cin plz");
		int c = new Scanner(System.in).nextInt();
		if(c==0) {
			T=null;
			return null;
		}
		else {
			T=new BiTree();
			T.value=c;
			T.lchild=PreCreateBiTree(T.lchild);
			T.rchild=PreCreateBiTree(T.rchild);
			return T;
		}
	}
	
	public static void PreOrderTraverse(BiTree T) {
		if(T==null) return;
		visit(T);
		PreOrderTraverse(T.lchild);
		PreOrderTraverse(T.rchild);
	}
	//T为二叉树中任意的结点，一般初值为根结点
	public static void InOrderTraverse(BiTree T) {
		if(T==null) return;
		InOrderTraverse(T.lchild);
		visit(T);
		InOrderTraverse(T.rchild);
	}
	public static void PostOrderTraverse(BiTree T) {
		if(T==null) return;
		PostOrderTraverse(T.lchild);
		PostOrderTraverse(T.rchild);
		visit(T);
	}
	public static void visit(BiTree t) {
		System.out.println("Visit:"+t.value);
	}
}
```









### 2、树的存储结构







#### **2.1对于二叉树**

**1、顺序存储**

特别适合于满二叉树，完全二叉树。 index从1开始存， 下标为i的节点其子节点下标是2i和2i+1

**2、二叉链表**

一般可以采用链式存储结构

```java
class Tree{
  int value;
  Tree lchild;
  Tree rchild;
}
```





#### 2.2对于一般的树

**1、双亲表示法**

parent[]数组， parent[i]=value 代表i的父节点是value结点,     特别注意所有的i和value都是索引index。

这种方法可以快速地找到一个结点的父节点，也可以递归地找到根节点。但是找孩子节点的话需要遍历整个结构。



**2、孩子表示法**

每个结点作为元素，组成一个线性表。然后线性表中每个节点又引领一个它的孩子节点链表.

```java
//实现方式：
ArrayList<ArrayList<integer>> ;

ArrayList<integer>[];//不合乎语法规范
```

```C++
//y总法:以边为核心，每条边都有一个编号
	//index：边号
	//h[i] 顶点i的的一条边号
	//e[index] index边的弧头
	//ne[index] index边的下一条边
	//w[index]  index边的权值
h[],e[],ne[],w[],idx;
```



**3、孩子兄弟表示法**







### 3、赫夫曼树以及应用



**一些概念：**

1.**路径**是 从树中一个节点到另一个节点之间的分支

2.**路径长度**是经过的分支的数目

3.**树的路径长路**是从树根到每一个节点路径长度之和

4.**结点的带权路径长度**是<u>到树根的路径长度</u>与<u>结点的权</u>之积

5.**树的带权路径长度**是所有叶子结点的带权路径长度之和 ，记作 WPL（Weighted Path Length）

6.**最优二叉树或赫夫曼树**是带权路径长度最小的二叉树



那么怎样由给定的权值，构造赫夫曼树呢？

**赫夫曼算法：**

由给定的n个权值，{w1,w2,w3,w4} 每次取出最小的两个权值合并后再加进去





**已知且可证**：

1.设计长度不等的编码要使用前缀编码；

2.可以利用二叉树来设计二进制的前缀编码，左分支代表‘0’ 右分支代表‘1’





**设计目标：用二进制数编码电文，且使总长最小**







**具体化**： 字符在电文中出现的次数（次数作为权重）为wi，编码长度为li，文中共有n种字符，则电文编码总长：$\sum^n_{i=1}   wi×li$

**码图对应：**n个字符对应 n个叶子结点，从叶子往上走 的该叶子字符的编码，从树根往下走，可以解码

**一些性质：**n个叶子结点的赫夫曼树有2n-1个结点





**赫夫曼源码：**

```C++
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <string>
#include <map>
#define INF 1<<27           //无穷大
#define Max_Char 40		        //最大字符种类数 （叶子结点数）
#define Max_Node Max_Char*2-1		//最大节点数
using namespace std;

typedef struct
{
	int weight;
	int lchild;
	int rchild;
	int parent;
	char name;          //结点代表的字符 ，对于非叶子结点可忽略
}Node;

Node NodeList[Max_Node+1];    //结点数组 从1开始
string passage;                //接收文章


//从1到p的范围内 寻找最小的两个权值的节点的下标，且节点的parent为-1
void Select(int p,int &s1,int &s2)
{
    int min1=INF,min2=INF;
    for(int i=1;i<=p;i++)
        if(NodeList[i].weight<min1&&NodeList[i].parent==-1)
            {
                min1=NodeList[i].weight;
                s1=i;
            }

    for(int i=1;i<=p;i++)
        if(NodeList[i].weight<min2&&NodeList[i].parent==-1&&i!=s1)
            {
                min2=NodeList[i].weight;
                s2=i;
            }

}

void Huffman()
{
    cout<<"请输入文章:"<<endl;
    getline(cin,passage);

    //统计字符种数，以及出现的个数
    map<char,int> m;
    for(int i=0;i<passage.length();i++)
        m[passage[i]]++;

    //结点总数
    int NodeNum=m.size()*2-1;
    //叶子结点初始化
    int i=1;
    for(map<char,int>::iterator it=m.begin();it!=m.end();it++)
    {
        NodeList[i].name=it->first;
        NodeList[i].weight=it->second;
        i++;
    }
    //所有节点初始化
    for(int i=1;i<=NodeNum;i++)
    {
        NodeList[i].parent=-1;
        NodeList[i].lchild=-1;
        NodeList[i].rchild=-1;
    }

    //求解过程：
    for(int p=m.size()+1;p<=NodeNum;p++)
    {
        int s1,s2;
        Select(p-1,s1,s2);
        NodeList[p].lchild=s1;NodeList[p].rchild=s2;
        NodeList[p].weight=NodeList[s1].weight+NodeList[s2].weight;
        NodeList[s1].parent=p;
        NodeList[s2].parent=p;
    }

    for(int i=1;i<=NodeNum;i++)
        cout<<NodeList[i].name<<"   "<<NodeList[i].weight<<"   "<<
        NodeList[i].parent<<"  "<<NodeList[i].lchild<<"  "<<NodeList[i].rchild<<endl;

}

int main()
{
    Huffman();
    return 0;
}
```

运行样例：<img src="C:\Users\95266\AppData\Roaming\Typora\typora-user-images\image-20200412202425692.png" alt="image-20200412202425692" style="zoom: 80%;" />



//解题的核心是贪心算法：每次循环寻找最小的两个权重的叶子结点（且结点尚未找到父节点也即 parent=-1）合并





fence repair 也是这个这个思想

可以借助于优先队列实现



### 4、前序中序后续转换

前序PreOrder: 	根左右	
中序InOrder： 	左根右	
后序PostOrder:	左右根

**根据前序或者后序可以得到==根==的位置**
**根据中序可以得到==左右子树==的元素**

**因此我们可以利用Preorder序列+Inorder序列得到Postorder序列  
或者Postorder序列+Inorder序列得到Preorder序列**





写代码的注意点：

1. **root、start、 end 都是索引**
2. **root 索引 preorder 或 postorder**
3. **start 和 end 索引 inorder**
4. 递归



#### (1)、后序+中序得前序

[柳婼后序+中序得前序](https://www.liuchuo.net/archives/2090)

```C++
#include <cstdio>
using namespace std;
int post[] = {3, 4, 2, 6, 5, 1};
int in[] = {3, 2, 4, 1, 6, 5};
void pre(int root, int start, int end) {
    if(start > end) return;
    int i = start;
    while(i < end && in[i] != post[root]) i++;
    printf("%d ", post[root]);
    pre(root - 1 - end + i, start, i - 1);
    pre(root - 1, i + 1, end);
}
int main() {
    pre(5, 0, 5);
    return 0;
}
```



#### (2)、前序+中序得后序

[柳婼前序+中序得后序](https://www.liuchuo.net/archives/2087)

```C++
#include <cstdio>
using namespace std;
int pre[] = {1, 2, 3, 4, 5, 6};
int in[] = {3, 2, 4, 1, 6, 5};
void post(int root, int start, int end) {
    if(start > end) 
        return ;
    int i = start;
    while(i < end && in[i] != pre[root]) i++;
    post(root + 1, start, i - 1);
    post(root + 1 + i - start, i + 1, end);
    printf("%d ", pre[root]);
}
int main() {
    post(0, 0, 5);
    return 0;
}
```

#### (3)前/后序+中序得层序

https://blog.csdn.net/liuchuo/article/details/52137796

分析：与后序中序转换为前序的代码相仿（无须构造二叉树再进行广度优先搜索～），只不过加一个变量index，表示当前的根结点在二叉树中所对应的下标（从0开始），所以进行一次输出先序的递归过程中，就可以把根结点下标index及所对应的值存储在map<int, int> level中，map是有序的会根据index从小到大自动排序，这样递归完成后level中的值就是层序遍历的顺序

在前面的基础上，前序访问时记录（完全二叉树）下标和根的关系



[再加个镜面翻转](https://www.liuchuo.net/archives/2096)







## 二、图

树和图的一个区别是：

1. 树中每一层的元素可能和下一层中多个元素相关，但只能与上一层的一个相关。
2. 图中则是任意的。



### **0、基础知识**

#### 一、概念

顶点 Vertex  、 弧Arc (有向边) 如<v1,v2>	、   边Edge(无向边) 如 (v1,v2)

G1={V1,VR}	或G={V，{E}}	也即图由顶点Vertex的集合和顶点关系的集合两部分组成





**有向图中：** 弧<v1,v2>		   有向完全图：弧的数目为n(n-1)
任意两个顶点、<u>强连通图</u>





**无向图中:**	边(v1,v2)			无向完全图：边的数目为n(n-1)/2
若任意两个顶点$v_1、v_2\in V$都是连通的，称之为<u>连通图</u>。而非连通图有x 个连通分量(极大连通子图：额外再添加一个点就会破坏连通性)（团）
一个连通图的生成树（极小连通子图）：含有图的全部n个顶点，且只有n-1条边，再加一条边就会有环。

- 顶点v的度 是和v相关联的边的数目，称为TD(v)

- 注意 邻接 和 连通 的区别





图可分为 有向图 有向网、无向图 无向网  (网是边或者弧上带有权值)
$$
图
\begin{cases}
有权 \begin{cases}  有向网\\无向网   \end{cases}
\\
无权 \begin{cases}  有向图\\无向图   \end{cases}
\end{cases}
$$



**团**是在子图中每两个顶点都有连接
**独立集**是子图中每两个顶点都没连接

**最大团**是 所有极大连通子图中 顶点数最大的那个
**独立集**是指图 中两两互不相邻的顶点构成的集合。
最大指的是顶点数最多的那一个

<u>求最大独立集问题，可以转化为其补图的最大团问题</u>





特别注意 value 与index的对应关系。往往是第i个位置，代表第i个结点。







#### 二、**图的存储结构：**

##### **1、邻接矩阵：**



```java
static final int MAXN=30;
static final int INF=0x3f3f3f3f;//注意！，因为可能存在加减溢出
static int n,m;
static int graph[][]=new int[MAXN][MAXN];
private static void CreateGraph() {
		Scanner sc = new Scanner(System.in);
		System.out.println("enter the num of vertex and edges!");
		n = sc.nextInt();//顶点数量
		m = sc.nextInt();//边的数量
		for(int i=0;i<n;i++) {
			for(int j=0;j<n;j++) {
				if(i==j) graph[i][j]=0;//注意!!!!!
				else
					graph[i][j]=INF;
			}
		}
		System.out.println("enter the edges and weight");//重边的处理
		for (int i = 0; i < m; i++) {
			int x = sc.nextInt();
			int y = sc.nextInt();
			int weight = sc.nextInt();
            graph[x][y]= math.min(garph[x][y], weight);
			graph[x][y]=weight;
			graph[y][x]=weight;
		}
	}
```





##### **2、邻接表：**

<img src="C:\Users\95266\AppData\Roaming\Typora\typora-user-images\image-20200413164346838.png" alt="image-20200413164346838" style="zoom:50%;" />

实现方式：

```java
//实现方式：
//1
ArrayList<ArrayList<integer>> al;

//2
vector<int>[] al;
```

```java
//3 前向星法！
//y总法 ，以边为核心的思想，给边赋予编号
//	index：边号
//	h[i] 顶点i的的第一条边号
//	e[index] index边的弧头
//	ne[index] index边的下一条边
//	w[index]  index边的权值
int h[], e[], ne[], w[], idx = 0;


//1初始化 莫忘！！！
idx=0;
Arrays.fill(h, -1);//java
memset(h, -1, sizeof h);//C++

//2插入边
	private static void Add(int a, int b, int weight) {
		e[idx]=b;		//创建index边
		w[idx]=weight;	//创建index边
		ne[idx]=h[a];	//确定index边的下一条边，把边加入到链表，头插法
		h[a]=idx++;		//把边加入到链表
	}
//3遍历边
//比如遍历编号4的顶点的所有边
for(int i = h[4]; i != -1; i = ne[i]){ //i是边的编号！！！！！！！！！！！！！！！，也即遍历每条边的编号
   int j = e[i];//边的弧头
   int w = w[j];//边的权值
}

```



<img src="C:\Users\95266\AppData\Roaming\Typora\typora-user-images\image-20210326195319024.png" alt="image-20210326195319024" style="zoom:50%;" />







### 1、 图的遍历

图的DFS、BFS跟 搜索里的DFS BFS不完全一样

#### **DFS**



#### **BFS**

















### 2、最小生成树

> n个城市之间需要连通，如何在n(n-1)/2条线路（或许少于n(n-1）/2)中选择出n-1条，使得总耗费最少呢？

Minimum Cost Spanning Tree 也即求连通所有地点的最小花费

最小生成树问题一般只针对**无向图**

<img src="C:\Users\95266\AppData\Roaming\Typora\typora-user-images\image-20210403103830239.png" alt="image-20210403103830239" style="zoom: 33%;" />

#### （1）Prim算法

**基本思路**：
给定连通网N=( V  ,  {E} )。 从 U={v1}   (已加入点集合，就是生成树点集) 、  TE={ 空 }  (已加入边集合)   开始，**不断地在点集 U 和 V-U  的边(u,v)中寻找最小的边加入TE**、加入U，直到U=V 。  此时TE中一定有且只有n-1条边， T=（V，TE）就是最小生成树。

**时间复杂度分析**：O(n^2)  **适合于边多的图！**

**可见**：Dijkstra是寻找两集合中到V0的最小值       Prim是寻找两集合中任意两点的最小值，**dist含义不同，前者是从V0到Vi的最短距离，后者是从任何点到Vi的最短距离**



yxc

```java
public class P858_Prim算法求最小生成树 {
	public static final int INF = 0x3f3f3f3f;
	public static final int MAXN = 510;
	static int n,m;
	static int g[][]= new int[MAXN][MAXN];
	static int dist[]=new int[MAXN];
	static boolean st[]=new boolean[MAXN];
	
	public static void main(String[] args) {
		CreateGraph();
		int ans=Prim();
		if(ans==INF) System.out.println("impossible");
		else System.out.println(ans);
	}//main

	private static int Prim() {
		Arrays.fill(dist, INF);
		Arrays.fill(st, false);
		int res=0;
        //n次循环，每次找到一个点
		for(int i=1;i<=n;i++) {
			//Scan 从未选集合中，找到到已选集合中最近的那个点
			int t = -1;
			for(int j = 1; j <= n; j++)
				if(!st[j] && ( t == -1 || dist[j] < dist[t] ) ) t = j;
			
			//Add
			st[t]=true;
			if(i != 1 && dist[t] == INF) return INF; 		//当找到的最近的一个点(非第一个点)都是INF时，说明存在非连通图直接return INF
			if(i != 1) res += dist[t];				//特判第一个点
			
			//Update
			for(int j=1;j<=n;j++) {
				if(!st[j] && dist[j]>g[t][j])
					//如果改成dist[j]=min(dist[j],g[t][j])的话注意：不会影响最终答案，因为
					//对于已加入点，即使dist被更新了，但是它已经设置成 st 为true了，不会影响Scan
					dist[j]=g[t][j];
			}
		}
		return res;
	}

	private static void CreateGraph() {
		Scanner sc = new Scanner(System.in);
		n = sc.nextInt();
		m = sc.nextInt();
		
		for (int i = 0; i <= n; i++) {
			for (int j = 0; j <= n; j++) {
				if(i==j) g[i][j]=0;
				else g[i][j] = INF;
			}
		}
		
		for (int i = 0; i < m; i++) {
			int a = sc.nextInt();
			int b = sc.nextInt();
			int w = sc.nextInt();
			g[a][b]=g[b][a]=Math.min(g[a][b], w);//处理重边
		}
	}
}
```



```java
/*
模板写法：
首先采用邻接矩阵graph存储带权图,注意用INF初始化
创建数组lowcost、adjvex,然后将第一个顶点加进去
n-1次循环寻找这n-1条边
*/
public class MiniSpanTree_Prim {
	public static final int MAXN = 20;
	public static final int INF =Integer.MAX_VALUE;
	static int graph[][]=new int[MAXN+1][MAXN+1];
	static int n=0;	//vertex
	static int m=0;	//edges
	static int cost=0;
	
	public static void main(String[] args) {
		CreateGraph();
		Prim();
		System.out.println("all cost:"+cost);
	}

	private static void Prim() {
		//S1:定义变量
		int lowcost[]=new int[MAXN];//存放从当前U中顶点到U-V中顶点的最小权值
		int adjvex[]=new int[MAXN];//配合lowcost数组，指定对应的U中的顶点
		//S2:初始化
		lowcost[1]=0;//将第一个顶点加入到U中
		for(int i=2;i<=n;i++) {
			lowcost[i]=graph[1][i];
			adjvex[i]=1;
		}
		
		//S3:开始寻找这n-1条边
		for(int i=1;i<=n-1;i++) {
			
			int min=INF/2;//注意在有权图中，我们用INF代表两边没有连接，因此min值一定不能比INF大
			int k=0;
			//S3.1:寻找当前最小边
			for(int j=1;j<=n;j++) {
				if(lowcost[j]!=0&&lowcost[j]<min) {
					min=lowcost[j];
					k=j;
				}
			}
			//S3.2:k加入到U
			System.out.println(adjvex[k]+"->"+k);
			cost+=min;
			lowcost[k]=0;//k点加入到U
			//S3.3:k点加入到U之后，更新
			for(int j=1;j<=n;j++) {
				if(lowcost[j]!=0&&graph[k][j]<lowcost[j]) {
					lowcost[j]=graph[k][j];
					adjvex[j]=k;
				}
			}
		}//for

	}//prim

	private static void CreateGraph() {
		Scanner sc = new Scanner(System.in);
		System.out.println("enter the num of vertex and edges!");
		n = sc.nextInt();//顶点数量
		m = sc.nextInt();//边的数量
		for(int i=0;i<=n;i++) {
			for(int j=0;j<=n;j++) {
				graph[i][j]=INF;
			}
		}
		System.out.println("enter the edges and weight");
		for (int i = 0; i < m; i++) {
			int x = sc.nextInt();
			int y = sc.nextInt();
			int weight = sc.nextInt();
			graph[x][y]=weight;
			graph[y][x]=weight;
		}
	}//CreateGraph

}//class
```









#### （2）Kruskal算法

**基本思路**：给定连通网 N=( V , {E} ) 。初始状态:T=(V,{ }),也即每个顶点自成一个连通分量。在E中选择权最小的边，如果落在T中不同的连通分量上，则选上，否则选择下一个权最小的边。

时间复杂度:O(mlogm)  **适合边少的图**

```java
class edge{
	int begin,end,weight;
	public edge(int begin, int end, int weight) {
		super();
		this.begin = begin;
		this.end = end;
		this.weight = weight;
	}
}

/*
模板写法：
首先用边集数组来存储图，然后按照weight从小到大排好序。用树的双亲表示法来代表集合 int []parent
从小到大遍历每一条边，对边的顶点进行求根运算（求根也即判定两顶点是否在同一个连通分量中），若根相同，在舍弃这条边（开启下一次循环）。否则，这条边入选（加入到集合中，也即加入到树结构中）
*/
public class MiniSpanTree_Kruskal {
	
	public static final int MAXN = 20;
	static int n=0,m=0;
	static edge edges[]=new edge[MAXN];
	static int parent[]=new int[MAXN];
	
	public static void main(String[] args) {
		CreateGraph();
		int ans = Kruskal();
        if( ans == -1) System.out.println("impossible")
		System.out.println(ans);
	}//main
    //采用边集数组结构
	private static void CreateGraph() {
		Scanner sc = new Scanner(System.in);
		System.out.println("enter the num of vertex and edges");
		n = sc.nextInt();
		m = sc.nextInt();
		System.out.println("enter the begin, end and weight");
		for (int i = 0; i < m; i++) {
			int begin = sc.nextInt();
			int end = sc.nextInt();
			int weight = sc.nextInt();
			edges[i]=new edge(begin, end, weight); 
		}
		Arrays.sort(edges, 0, m, (o1,o2)->o1.weight-o2.weight);
	}
	
	private static int Kruskal() {
        int res=0,cnt=0;
		Arrays.fill(parent, -1);
		//遍历所有的边
		for (int i = 0; i < m; i++) {
			
			int root_be = Find(edges[i].begin);	//顶点begin所在的树(集合)的根x 
			int root_en = Find(edges[i].end);	//顶点end所在的树(集合)的根y
			
			//两点处于不同的集合中（连通分量）则合并之，（该边入选）
			if(root_be != root_en) {
				parent[root_be] = root_en;
				res += edges[i].weight;
                  cnt++;
			}
		}
        if(cnt<n-1) return -1;  //n个顶点，选不够n-1条边  说明非连通
        else return res;
	}
	private static int Find(int x) {
		while(parent[x]!=-1) {
			x=parent[x];
		}
		return x;
	}

	
}

```

进阶版是利用并查集的思路，添加rank数组维护parent树的层数







#### （3）对比

**Prim** 		时间复杂度分析：O(n^2)  	**适合于边多的图！**，用邻接矩阵存储

**Kruskal** 	时间复杂度:O(eloge)  		**适合边少的图**			，用边集数组存储





### 3、二分图

一个图是二分图当且仅当能被2染色
一个图是二分图 当且仅当 图中不含奇数环

如果一个图能用二染色，而没有矛盾出现的话，那么就是一个二分图

<img src="C:\Users\95266\AppData\Roaming\Typora\typora-user-images\image-20210403103830239.png" alt="image-20210403103830239" style="zoom: 33%;" />



#### **二分图的判断**

```java
public class P860_染色法判定二分图 {
	public static final int MAXN = 100010;
	public static final int MAXM = 200010;
	
	static int n,m;
	static int e[]=new int[MAXM],h[]=new int[MAXN],ne[]=new int[MAXM],idx=0;
	static int color[]=new int[MAXN];
	static boolean flag = true;
	
	public static void main(String[] args) {
		CreateGraph();
		for(int i = 1; i <= n; i++ ) {
			if(flag) {
				if(color[i]==0) {
					dfs(i,1);
				}
			}else {
				break;
			}
		}
		if(!flag) System.out.println("No");
		else System.out.println("Yes");
	}//main

	private static void dfs(int idx, int c) {
		if(!flag) return;
		color[idx] = c;
		
		for(int i = h[idx]; i != -1 ; i = ne[i]) {
			int j = e[i];
			if(color[j] == 0)
				dfs(j, 3-c);
			else if(color[j] == c)
				flag = false;
		}
	}

	private static void CreateGraph() {
		Scanner sc = new Scanner(System.in);
		n = sc.nextInt();
		m = sc.nextInt();
		Arrays.fill(h, -1);
		for (int i = 0; i < m; i++) {
			int a = sc.nextInt();
			int b = sc.nextInt();
			add(a, b);
			add(b, a);
		}
	}

	private static void add(int a, int b) {
		e[idx] = b;
		ne[idx] = h[a];
		h[a] = idx++;
	}
}
```





#### **匈牙利算法**

可以在比较快的时间内，求出左边和右边匹配成功的最大数量   匹配成功：不存在两条边共用一个点

> 二分图的匹配：给定一个二分图 G，在 G 的一个子图 M 中，M 的边集 {E} 中的任意两条边都不依附于同一个顶点，则称 M 是一个匹配。
>
> 二分图的最大匹配：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数。

```java
public class P861_二分图的最大匹配_匈牙利算法 {
	public static final int MAXN = 510;
	public static final int MAXM = 100010;

	static int n1, n2, m;
	static int h[] = new int[MAXN], e[] = new int[MAXM], ne[] = new int[MAXM], idx = 0;
	static int match[] = new int[MAXN]; // 表示每个妹子当前的归属
	static boolean st[] = new boolean[MAXN]; // 记录妹子是否被访问过

	public static void main(String[] args) {
		CreateGraph();

		int res = 0;
		for (int i = 1; i <= n1; i++) {
			Arrays.fill(st, false);
			if (find(i))
				res++;
		}

		System.out.println(res);

	}// main

	/*
	 * 对于当前男生x ,看是否能找到匹配的妹子,如果能的话就返回true,并更新各个match
	 */
	private static boolean find(int x) {
		// 枚举男生x心仪的妹子列表j
		for (int i = h[x]; i != -1; i = ne[i]) {
			int j = e[i];	
			if (!st[j]) {	//如果妹子被访问过了，就不再访问了
				st[j] = true;
				if (match[j] == 0 || find(match[j])) {
					//如果妹子j没有找到男朋友，或者其男朋友match[j]可以另寻他人的话，那么男生x就可以和j配对了
					match[j] = x;
					return true;
				}
			}
		}
		return false;
	}

	private static void CreateGraph() {
		Scanner sc = new Scanner(System.in);
		n1 = sc.nextInt();
		n2 = sc.nextInt();
		m = sc.nextInt();
		Arrays.fill(h, -1);
		for (int i = 0; i < m; i++) {
			int a = sc.nextInt();
			int b = sc.nextInt();
			add(a, b);
		}
	}

	private static void add(int a, int b) {
		e[idx] = b;
		ne[idx] = h[a];
		h[a] = idx++;
	}

}
```















### 4、最短路

#### （0）总结

<img src="C:\Users\95266\AppData\Roaming\Typora\typora-user-images\image-20210331210841007.png" alt="image-20210331210841007" style="zoom:33%;" />



根据存储方式的不同： 邻接表（前向星，用于稀疏图）可以自己处理重边，而邻接矩阵（用于稠密图）要自己处理重边。

**写法：**

相似之处：都要有dist INF、 dist[1]=0;

- 朴素Dij：邻接矩阵、dist、st
- 堆优化Dij：邻接表、dist、st、priorityqueue、 class distance或pair
- Bellman-ford：边集数组、dist、**不需要st** 、class edge   **backup**
- SPFA：邻接表、dist、st 、queue
- Floyd和Bellman的无穷大会被无穷大更新，因此判断条件是>INF/2



- **单源最短路** 无负权用Dijkstra算法，根据是否稀疏再选择朴素或者堆优化（如果mn是一个数量级，比如遍数是顶点数的二倍这就是稀疏图）。有负权  用SPFA，若对经过的边数存在限制，用B-Ford
- **多源最短路**用Floyd



- 朴素Dijstra适合于边多的稠密图， 堆优化适用于稀疏图

**m和n^2一个级别的时候是稠密图**       边数是顶点数的平方倍
**m和n是一个级别的时候是稀疏图**        边数和顶点数是一个数量级

- dijkstra 是贪心策略 、  floyd 动态规划

- 难点在于：建图，建模



SPFA 在经有过不超过k条边时的限制时，就不能用了



#### (1)朴素Dijkstra算法

> 问题：怎样求从一个点到另外所有点的最短路呢？

**适用于：**正权边，且是稠密图     

**时间复杂度：**  O(n^2)

**存储：**用邻接矩阵

<img src="C:\Users\95266\AppData\Roaming\Typora\typora-user-images\image-20210325170132217.png" alt="image-20210325170132217" style="zoom: 33%;" />

**基本思路：**有一个已加入点集合T和 一个未加入点集合。刚开始是把V0加入到已选顶点集合中。然后重复执行操作：找到当前从V0到某个未选点集合中最短距离的那个顶点 t (**Scan**)，将其加入到已选点集合(**Add**)，然后更新途径该结点 t 到其他未选顶点的距离(**Update**)。最后得到的dist数组就是V0到其他顶点的最短距离。

**注意：**对于出现自环（正权）那么就不用考虑，对于重边，只需要保留长度最短的那一个g[i] [j]=Min(g[i] [j],w)。Dijkstra要求不能存在负权边！！！！！有的话就用SPFA或BellManFord



**yxc朴素Dijkstra算法：（可以有重边或自环）**

```java
/*
题意：给定有向网（可有重边和自环且m和n的平方是一个数量级 稠密图），问从V1到Vn的最短距离是多少？
思路：用朴素Dijkstra
*/
public class P849_Dijkstra求最短路1 {
	public static final int MAXN = 510;
	public static final int INF =0x3f3f3f3f;
	
	static int n,m;
	static int g[][]=new int[MAXN][MAXN];		
	static int dist[]=new int[MAXN];			//其他点到V1的距离
	static boolean st[]=new boolean[MAXN];	//记录某点是否已加入已选点集合
	
	public static void main(String[] args) {
		CreateGraph();
		int ans=Dijkstra();
		System.out.println(ans);
	}//main
	
	private static void CreateGraph() {
		Scanner sc = new Scanner(System.in);
		n = sc.nextInt();
		m = sc.nextInt();
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= n; j++) {
				if(i==j) g[i][j]=0;
				else g[i][j]=INF;
			}
		}
		for (int i = 0; i < m; i++) {
			int x = sc.nextInt();
			int y = sc.nextInt();
			int w = sc.nextInt();
			g[x][y]=Math.min(g[x][y], w); //处理重边！！！
		}
	}

	private static int Dijkstra() {
		//S1初始化
		Arrays.fill(dist, INF);
		Arrays.fill(st, false);
		
		dist[1]=0;
		//S2:n次循环,每次循环加入一个点
		for(int i=0;i<n;i++) {
			//Scan
			int t=-1; 
			for(int j=1;j<=n;j++) 
				if(!st[j] && (t==-1||dist[j]<dist[t])) t=j;
			//Add
			st[t]=true;
			//Update 
            //途径 t 到 j
			for(int j=1;j<=n;j++) 
				if(!st[j] && dist[t]+g[t][j]<dist[j])
					dist[j] = dist[t] + g[t][j];
		}
		
		if(dist[n]==INF)//从V1到Vn不存在最短路径(也即非连通)  
            //因为不存在负权，因此不用担心无穷大被无穷大更新，因此比较时==INF
			return -1;
		else 
			return dist[n];
	}
}
```



```java
/*
王晨的写法：
模板思路:
Dijkstra是求单源最短路算法，也即从v0到其他各点的最短路
三个数组 visited,dist,parent  作用：决定某点是否入选已选点集合 、
主要的三个步骤是 Scan Add Update
Scan:寻找V0到当前未选顶点数组中距离最短的那一个顶点k
Add:将该点k加入到已选数组中
Update:途径k点到其他未选顶点的距离是否更小
*/
public class ShortestPath_Dijkstra {
	
	public static final int MAXN = 20;
	public static final int INF = Integer.MAX_VALUE-100000;//加法可能存在溢出
	static int n,m;//顶点的数量 和 边的数量
	static int graph[][]=new int[MAXN][MAXN];
	
	public static void main(String[] args) {
		CreateGraph();
		Dijkstra();
	}//main
	
	private static void Dijkstra() {
		//S1:定义变量
		boolean visited[]=new boolean[MAXN];//决定某点是否入选已选点集合 
		int dist[]=new int[MAXN];			//从V0到某点的最短距离
		int parent[]=new int [MAXN];		//到某点的最短路径中，该点的上一个结点
		//S2:初始化
		for (int i = 0; i < n; i++) {
			visited[i]=false;
			dist[i]=INF;
			parent[i]=-1;
		}
		//S3:加入v0
		dist[0]=0;
		visited[0]=true;
		for (int i = 1; i < n; i++) {//对于另一个非连通图的点，下面的初始化，就是最终值了
			dist[i]=graph[0][i];
			parent[i]=0;
		}
		
		//S4:n-1次循环，每次找到一个从v0到某个未选顶点的最短路径
		for(int i = 1; i <= n-1; i++) {
			//S4.1:寻找当前某个未入选的点，该点到v0的距离最短
			int k=-1;
			for (int j = 0; j < n; j++) {
				if(!visited[j]&&(k==-1||dist[j]<dist[k])) {
					k=j;
				}
			}
			
			//S4.2:把找到的该点加入到已选点的集合中取
			visited[k]=true;
			System.out.println(k+"加入到已选点集合!");
			
			//S4.3:更新通过该点到其他未入选点的距离，看是否更小
			for (int j = 0; j < n; j++) {
				if(!visited[j]&&dist[k]+graph[k][j]<dist[j]) {
					dist[j]=dist[k]+graph[k][j];
					parent[j]=k;
				}
			}
		}
		
		//查询
		for (int i = 0; i < n; i++) {
			System.out.println("从v0顶点到"+i+"顶点的最短距离是"+dist[i]);
		}
		System.out.println("the vertex in the path from 0 to 5:");
		PrinLastOne(5,parent);	
	}

	private static void PrinLastOne(int i, int[] parent) {
		if(parent[i]!=-1)
			PrinLastOne(parent[i], parent);
		System.out.print(i+" ");
	}

	private static void CreateGraph() {
		Scanner sc = new Scanner(System.in);
		System.out.println("enter the num of vertex and edges!");
		n = sc.nextInt();//顶点数量
		m = sc.nextInt();//边的数量
		for(int i=0;i<n;i++) {
			for(int j=0;j<n;j++) {
                if(i==j) graph[i][j]=0;
                else graph[i][j]=INF;
			}
		}
		System.out.println("enter the edges and weight");
		for (int i = 0; i < m; i++) {
			int x = sc.nextInt();
			int y = sc.nextInt();
			int weight = sc.nextInt();
			graph[x][y]=weight;
			graph[y][x]=weight;
		}
	}
}
数据
6 9
0 1 1
0 2 12
1 2 9
1 3 3
2 3 4
2 4 5
4 3 13
3 5 15
4 5 4
```





#### （2）堆优化版的dijkstra

**分析：**

首先考虑一下朴素版的时间复杂度，如下可见是 O(n^2)，对于稀疏图 (n、m同级，且n较大)时，会TLE。

但用堆（优先队列）优化之后。在一堆数中寻找一个最小的数 ，是O(1)的。在堆中修改一个数是logn的。（图用邻接表）总时间复杂度降为O(mlogn)

> 堆的实现：①、手写堆 保证n个数  。    ②、优先队列：不支持修改任意一个元素的操作，因此实现的方式是冗余，也即每次修改就往里面加一个数。 

**基本思路**：与朴素一致，都是Scan、Add、Update。只是在找最小值时Scan和更新Update时用堆做替代（堆里存的是V0到V...的某一时刻的最短距离，注意冗余，此外堆里除了距离以外还要有编号）。因为有冗余的存在，因此找到的最小值之前可能确定过了，因此要用st判断一下。 

**适用于：**稀疏图  

**时间复杂度**是**O(mlogn)**

**存储：**邻接表



**yxc代码：** [https://www.acwing.com/blog/content/405/](https://www.acwing.com/blog/content/405/)

```C++
/*
题意：给定一个稀疏网，求从V1到Vn的最短路
*/
typedef pair<int, int> PII;

int n;      // 点的数量
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N];        // 存储所有点到1号点的距离
bool st[N];     // 存储每个点的最短距离是否已确定

// 求1号点到n号点的最短距离，如果不存在，则返回-1
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap;//从低到高的优先队列
    heap.push({0, 1});      // first存储距离，second存储节点编号

    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();

        int ver = t.second, distance = t.first;

        if (st[ver]) continue;
        st[ver] = true;

        for (int i = h[ver]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > distance + w[i])
            {
                dist[j] = distance + w[i];
                heap.push({dist[j], j});
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```



**我的实现：**

```java
/*
题意：给定一个稀疏网，求从V1到Vn的最短路
*/
class distance{
	int dis=-1;
	int index=-1;
	public distance(int dis, int index) {
		super();
		this.dis = dis;
		this.index = index;
	}
}

public class P850_Dijkstra求最短路2 {
	public static final int INF = Integer.MAX_VALUE/2;
	public static final int MAXN = 150010;
	static int n,m;
	static int h[]=new int[MAXN],e[]=new int[MAXN],ne[]=new int[MAXN],w[]=new int[MAXN],idx=0;
	static int dist[]=new int[MAXN];
	static boolean st[]=new boolean[MAXN];
	
	public static void main(String[] args) {
		CreateGraph();
		int ans=Dijstra();
		System.out.println(ans);
	}//main

	private static int Dijstra() {
		//S1初始化
		Arrays.fill(dist, INF);
		Arrays.fill(st, false);
		PriorityQueue<distance> heap = new PriorityQueue<distance>((o1,o2)->o1.dis-o2.dis);
		
        dist[1]=0;
		heap.offer(new distance(0, 1));
		//S2
		//朴素的做法是：n次循环，每次循环找到一个顶点加入到集合中，for里干的事是Scan Add Update
		//堆优化的做法是：对堆进行循环  ，做的也是Scan Add Update,只不过用堆来优化了 
		while(!heap.isEmpty()) {
            //Scan
			distance t = heap.poll();//O1的时间里找到了到V1最小距离的点,注意判定这个距离是不是有效的
			int TempIdx=t.index,TempDis=t.dis;
			//在堆中，中途会加入到某点比如说Vi很多暂时不是最短的距离，当st[i]设置成true时,这些在堆中的到i的距离就失效了，但是可能优先弹出，因此要跳过！
			if(st[TempIdx]) continue;
			//Add
			st[TempIdx]=true;//加入到已选点集合
			for(int i=h[TempIdx];i!=-1;i=ne[i]) {//遍历所有边 i是边的编号			//O(mlogn)
				int j=e[i];
				if(!st[j]&&TempDis+w[i]<dist[j]) {
					dist[j]=TempDis+w[i];
					heap.offer(new distance(dist[j], j));
				}
			}
			
		}
		
		if(dist[n]==INF) return -1;//非连通
		else return dist[n];
	}


	private static void add(int a, int b, int weight) {
		e[idx]=b;
		w[idx]=weight;
		ne[idx]=h[a];
		h[a]=idx++;
	}
	private static void CreateGraph() {
		Scanner sc = new Scanner(System.in);
		n = sc.nextInt();
		m = sc.nextInt();
		Arrays.fill(h, -1);
		for (int i = 0; i < m; i++) {
			int a = sc.nextInt();
			int b = sc.nextInt();
			int weight = sc.nextInt();
			add(a,b,weight);//用邻接表 有重边也没事，算法会考虑
		}
	}
	
	
	
}
```



#### （3）Bellman-Ford算法

**适用于**：存在负权边，且经过不超过k条边

>  **扩展：**
>
> - 当图中存在负权回路时，是不一定存在最短路的，因为可以无限走圈
> - **迭代K次之后(for)的dist数组的含义是：从1号点经过不超过K条边，走到每个点的距离。**
> - Bellman-Ford算法可以求图中是否存在负权回路：如果第n次迭代的时候仍更新了某条边，说明了：存在一条最短路径，边的个数是大于等于N，抽屉原理则说明一定存在负环，因此BellmanFord可以用来找负环，但一般不用因为复杂度高，而是用SPFA来做
> - 循环完之后所有边的距离都满足 dist[b]<=dist[a]+w  (三角不等式)，更新的过程叫松弛操作。
> - 当限制了经过不超过K条边时，存在负环也无所谓了，因为不能无限转了

**时间复杂度：O(nm)**

BellmanFord算法基本思路：<img src="C:\Users\95266\AppData\Roaming\Typora\typora-user-images\image-20210331161333699.png" alt="image-20210331161333699" style="zoom: 67%;" />



```java
class edge{
	int a,b,w;
	public edge(int a, int b, int w) {
		super();
		this.a = a;
		this.b = b;
		this.w = w;
	}
}

public class P853_有边数限制的最短路 {
	public static final int INF = Integer.MAX_VALUE/2;
	public static final int MAXN = 510;
	public static final int MAXM = 10010;
	static int n,m,k;//n个顶点  m条边   不超过k条边
	static edge edges[]=new edge[MAXM];
	static int dist[]=new int[MAXN],backup[]=new int[MAXN];//备份数组
	
	public static void main(String[] args) {
		CreateGraph();
		int ans=bellman_ford();
		if(ans==-1) System.out.println("impossible");
		else System.out.println(ans);
	}//main

	private static void CreateGraph() {
		Scanner sc = new Scanner(System.in);
		n = sc.nextInt();
		m = sc.nextInt();
		k = sc.nextInt();
		for (int i = 0; i < m; i++) 
        {
			int a = sc.nextInt();
			int b = sc.nextInt();
			int w = sc.nextInt();
			edges[i]=new edge(a, b, w);
		}
	}

	private static int bellman_ford() {
		Arrays.fill(dist, INF);
		dist[1]=0;
		
		//经过不超过k条边，因此是k次迭代
		for(int i=0;i<k;i++) {
			//防止串联，因此备份
			System.arraycopy(dist, 0, backup, 0, dist.length);
			for(int j = 0;j < m; j ++) {//所有边
				int a = edges[j].a;
				int b = edges[j].b;
				int w = edges[j].w;
				dist[b]=Math.min(dist[b], backup[a]+w);//注意此步 可能存在(无穷大)被(无穷大-w)更新了.
			}
		}
		if(dist[n] > INF/2) return -1;//注意
		else return dist[n];
	}
}
```







#### (4)SPFA

SPFA算法是BellmanFord算法的队列优化版

**适用于：**不能存在负环 
		

**时间复杂度**：一般是O（m），最坏情况O(nm)

**存储**：用邻接表

> 注意：
>
> - 代码长得像堆优化dijstra
> - 判负环一般用SPFA
> - 虽然正权图一般用Dijkstra，但大部分的正权图用SPFA也可以做。

==**基本思路：**==
谁被更新了，谁才有权去更新别人。因为只有我变小了，我后面的人才会变小。也即，<u>我们设置一个队列，进队的都是刚刚更新了距离的**结点号**，这些结点有权去更新别的结点，此外需要定义一个st数组来维护队列的不重复性（也即一出队就st[]=false,一入队st=true），来防止结点号重复入队。</u>

```java
public class P851_spfa求最短路 {
	public static final int INF = Integer.MAX_VALUE/2;
	public static final int MAXN = 150010;
	static int n,m;
	static int h[]=new int[MAXN],e[]=new int[MAXN],ne[]=new int[MAXN],w[]=new int[MAXN],idx=0;
	static int dist[]=new int[MAXN];
	static boolean st[]=new boolean[MAXN];
	
	public static void main(String[] args) {
		CreateGraph();
		int ans=spfa();
		if(ans==-1) System.out.println("impossible");
		else System.out.println(ans);
	}//main
	// △！！谁被更新了，谁才有权去更新别人
	// 把更新了的点加入一个队列(称为更新队列)，st维护队列的不重复性
	private static int spfa() {
		Arrays.fill(dist, INF);
		LinkedList<Integer> queue = new LinkedList<Integer>();
        
         dist[1]=0;
		queue.offer(1);
		st[1]=true;
		
		while(!queue.isEmpty()) 
        {
			Integer t = queue.poll();
			st[t]=false;
			for(int i=h[t];i!=-1;i=ne[i]) 
            {
				int j = e[i];
				if(dist[t]+w[i]<dist[j] ) 
                 {
					dist[j]=dist[t]+w[i];//被更新了，且没有在队里，那么就入队
					if(!st[j]) 
                      {
						queue.offer(j);
						st[j]=true;
					}
				}
			}//for
		}//while
		
		if(dist[n]==INF) return -1;
		return dist[n];
	}


	private static void add(int a, int b, int weight) {
		e[idx]=b;
		w[idx]=weight;
		ne[idx]=h[a];
		h[a]=idx++;
	}
	private static void CreateGraph() {
		Scanner sc = new Scanner(System.in);
		n = sc.nextInt();
		m = sc.nextInt();
		Arrays.fill(h, -1);//莫忘
		for (int i = 0; i < m; i++) {
			int a = sc.nextInt();
			int b = sc.nextInt();
			int weight = sc.nextInt();
			add(a,b,weight);//用邻接表 有重边也没事，算法会考虑
		}
	}
}
```





**SPFA判负环**

**原理：**首先我们知道 dist[x] 存的是从1到其他点的最短距离 、那么我们 再构建一个cnt[x]数组，存的是从1到x的最短路所经过的边数。
因此我们有：dist[x]=dist[t]+w[i];   、cnt[x] = cnt[t]+1    
因此 当 cnt[x]>=n 时，根据抽屉原理，必有负环

代码相较于一般的spfa的区别是： 

- 判负环要全部入队，并设置为true，且不用dist数组
- 判负环要多一个cnt[ ]数组，存的是从1到x的最短路所经过的边数,每当有更新就+1；

```java
public class P852_spfa判断负环 {
	public static final int MAXN = 2010;
	public static final int MAXM = 10010;
	public static final int INF = 0x3f3f3f3f;
	
	static int m,n;
	static int h[]=new int[MAXM],e[]=new int[MAXM],ne[]=new int[MAXM],w[]=new int[MAXM],idx=0;
	static int dist[]=new int[MAXN],cnt[]=new int[MAXN];
	static boolean st[]=new boolean[MAXN];
    
	public static void main(String[] args) {
		CreateGraph();
		if(spfa()) System.out.println("Yes");
		else System.out.println("No");
	}//main
    
	private static boolean spfa() {
		LinkedList<Integer> queue = new LinkedList<Integer>();
        /* 不用初始化的原因是：不需要记录最短路径，而只需要记录更新就行
        不加入第一个点的原因：有负环的路径可能从任意一点出发
        Arrays.fill(dist, INF);
		LinkedList<Integer> queue = new LinkedList<Integer>();
         dist[1]=0;
		queue.offer(1);
		st[1]=true;
        */
		for(int i = 1; i <= n;i ++) {
			queue.offer(i);
			st[i]=true;
		}
		
		while(!queue.isEmpty()) {
			Integer t = queue.poll();
			st[t]=false;
			
			for(int i=h[t];i!=-1;i=ne[i]) {
				int j=e[i];
				if(dist[t]+w[i]<dist[j]) {
					dist[j]=dist[t]+w[i];
					cnt[j]=cnt[t]+1;
					if(cnt[j]>=n) return true;
					if(!st[j]) {
						st[j]=true;
						queue.offer(j);
					}
				}
			}
		}//while
		
		return false;
	}
	private static void CreateGraph() {
		Scanner sc = new Scanner(System.in);
		n = sc.nextInt();
		m = sc.nextInt();
		Arrays.fill(h, -1);
		for (int i = 0; i < m; i++) {
			int a = sc.nextInt();
			int b = sc.nextInt();
			int we = sc.nextInt();
			add(a,b,we);
		}
	}
	private static void add(int a, int b, int we) {
		e[idx]=b;
		w[idx]=we;
		ne[idx]=h[a];
		h[a]=idx++;
	}
}
```







#### (5)多源Floyd

> 问题：给定一个 n 个点 m 条边的有向图，**图中可能存在重边和自环，边权可能为负数**。
>
> 再给定 k 个询问，每个询问包含两个整数 x 和 y，表示查询从点 x 到点 y 的最短距离，如果路径不存在，则输出 `impossible`。
>
> **数据保证图中不存在负权回路。**
>
> **分析**：
> ①、重边的处理是只保留最小的那个，(做法是：g[i] [j]=min(g[i] [j] , w)    )    
> ②、自环的处理是：因为不含负权回路，那么自环只能是正自环，因此对于正自环我们可以直接删去（做法是：设置成0



**思考：**将边权设置成INF后的相加减要注意

**基本思路：**

yxc

```java
public class P854_Floyd求最短路 {
	public static final int INF = Integer.MAX_VALUE/3;
	public static final int MAXN = 210;
	public static final int MAXM = 10010;
	static int n,m,k;
	static int d[][]=new int[MAXN][MAXN];
	static Scanner sc = new Scanner(System.in);
	public static void main(String[] args) {
		CreateGraph();
		Flod();
		//Query
		while(k--!=0) {
			int a = sc.nextInt();
			int b = sc.nextInt();
			if(d[a][b]>INF/2) System.out.println("impossible");
            //Floyd和BellmanFord的无穷大都可能被另一个更小的无穷大更新
			else System.out.println(d[a][b]);
		}

	}//main

	private static void Flod() {
		for(int k=1;k<=n;k++)//3重循环，从i到j经过k
			for(int i=1;i<=n;i++)
				for(int j=1;j<=n;j++)
					d[i][j]=Math.min(d[i][j], d[i][k]+d[k][j]);
	}

	private static void CreateGraph() {
		n = sc.nextInt();
		m = sc.nextInt();
		k = sc.nextInt();
		for (int i = 0; i <= n; i++) {
			for(int j = 0; j <= n; j++) {
				if(i == j) d[i][j]=0;
				else d[i][j]=INF;
			}
		}
		
		for (int i = 0; i < m; i++) {
			int a = sc.nextInt();
			int b = sc.nextInt();
			int w = sc.nextInt();
			d[a][b]=Math.min(d[a][b], w);//处理重边
		}
	}
}

```



我的

```java
import java.util.Scanner;

public class ShortestPath_Floyd {
	public static final int MAXN = 20;
	public static final int INF = Integer.MAX_VALUE/10;//出现加法，防止溢出
	static int n,m;//点 边
	static int graph[][]=new int[MAXN][MAXN];
	static int d[][]=new int[MAXN][MAXN];		//存两个顶点之间的最短路径长度
	static int p[][]=new int[MAXN][MAXN];		//存两个顶点最短路径，对应的前驱节点
	public static void main(String[] args) {
		CreateGraph();
		Floyd();
	}//main
	
	private static void Floyd() {
		//初始化
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				d[i][j]=graph[i][j];
				p[i][j]=j;			//注意此处,初始化成终点的下标
			}
		}
		//三重循环
		for (int k = 0; k < n; k++) {
			for(int v = 0; v < n; v++) {
				for(int w = 0; w < n; w++) {//从v到w途径k结点
					if(d[v][w]>d[v][k]+d[k][w]) { 
						d[v][w]=d[v][k]+d[k][w];
						p[v][w]=p[v][k];
					}
				}
			}
		}
		
		
		//展示
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				System.out.print(d[i][j]+" ");
			}
			System.out.println();
		}
		System.out.println("\n\n");
		System.out.println(0+" "+1+" "+2+" "+3+" "+4+" "+5+"\n");
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				System.out.print(p[i][j]+" ");
			}
			System.out.println();
		}
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				System.out.print("从"+i+"到"+j+"最短路的路径是：");
				int temp=p[i][j];//1
				System.out.print(i+" ");
				while(p[temp][j]!=j) {
					System.out.print(temp+" ");
					temp=p[temp][j];
				}
				System.out.println(temp+" "+j);
			}
		}
		
		
		
	}


	private static void CreateGraph() {
		Scanner sc = new Scanner(System.in);
		System.out.println("enter the num of vertex and edges!");
		n = sc.nextInt();//顶点数量
		m = sc.nextInt();//边的数量
		for(int i=0;i<n;i++) {
			for(int j=0;j<n;j++) {
				if(i==j) graph[i][j]=0;//初始化成0 也即自己到自己的距离为0，这样比INF更好
				else
					graph[i][j]=INF;
			}
		}
		System.out.println("enter the edges and weight");
		for (int i = 0; i < m; i++) {
			int x = sc.nextInt();
			int y = sc.nextInt();
			int weight = sc.nextInt();
			graph[x][y]=weight;
			graph[y][x]=weight;
		}
	}
}
```

#### （6）拓展：超级源点

>  背景：给出题目，在一张图中有多个点起点，一个终点，求所有起点到终点的最短距离。

**解题方法：**

1.跑N边单源最短路，但是这样是不行的肯定超时。

2.floyd求出所有最短路，枚举每个起点到终点的距离，这个似乎比法1更慢。

3.反向建边，反向跑一遍Dijkstra，或者SPFA，这样就能求到终点到所有起点的距离。

4.**建立超级源点，虚拟出一个点作为源点，源点到所有起点的距离都是0，那么这样求超级源点到终点的最短距离就是所有起点到终点的距离的最短一个，时间复杂度为一遍最短路。**





一个例子：

> 题意：给出一张图，图中有一个起点的集合和一个终点的集合，求从起点集合到终点集合的距离中的最短距离。  也即多源多汇求最短路，我们可以同时建立**超级源点**和**超级汇点**

<img src="C:\Users\95266\AppData\Roaming\Typora\typora-user-images\image-20210407174102901.png" alt="image-20210407174102901" style="zoom:33%;" />》建立之后》<img src="C:\Users\95266\AppData\Roaming\Typora\typora-user-images\image-20210407174347844.png" alt="image-20210407174347844" style="zoom:33%;" />





### 5、拓扑排序 

**一些概念：**

- DAG (Directed Acyclic Graph)有向无环图

- AOV (Activity On Vertex Network) 顶点表示活动，弧表示活动之间的优先关系的有向网

AOV网是一种有向无回路的图。

- 拓扑序列：
- 拓扑排序：对有向图进行拓扑排序，会得到两个结果:1全部顶点被输出，说明有向图是AOV网。2没有被完全输出，有向图不是AOV网



**拓扑排序算法：**



<img src="C:\Users\95266\AppData\Roaming\Typora\typora-user-images\image-20210327164002404.png" alt="image-20210327164002404" style="zoom:33%;" />







算法结束时没有访问所有顶点，则剩下的顶点是个环

<img src="C:\Users\95266\AppData\Roaming\Typora\typora-user-images\image-20210327164217836.png" alt="image-20210327164217836" style="zoom:33%;" />

<img src="C:\Users\95266\AppData\Roaming\Typora\typora-user-images\image-20210327164250340.png" alt="image-20210327164250340" style="zoom:50%;" />





注意拓扑序列不唯一

<img src="C:\Users\95266\AppData\Roaming\Typora\typora-user-images\image-20210327165528059.png" alt="image-20210327165528059" style="zoom:33%;" />



源码

**基本思路：**寻找当前图中**入度为0**的顶点（没有前驱），然后删除该节点和它相连的边，再寻找入度为0的节点，再重复操作

```java
public class 有向图的拓扑序列 {
	static final int MAXN = 100010;
	static int n,m;
	static int h[]=new int[MAXN], e[]=new int[MAXN],
			ne[]=new int[MAXN], in[]=new int[MAXN], idx=0, count=0;
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		n = sc.nextInt();
		m = sc.nextInt();
		Arrays.fill(h, -1);
		for (int i = 0; i < m; i++) {
			int x=sc.nextInt();
			int y=sc.nextInt();
			Add(x,y);
			in[y]++;
		}
		
		//bfs寻找拓扑序列
        //不用设置visited数组，因为每个顶点可以被访问多次(因为要删入度)
		ArrayList<Integer> res = new ArrayList<Integer>();
		LinkedList<Integer> queue = new LinkedList<Integer>();
		//入度为0的点进队
		for (int i = 1; i <= n; i++) {
			if(in[i]==0) queue.add(i);
		}
		
		while(!queue.isEmpty()) {
			//出队并输出入度为0的点，并执行删除操作
			Integer poll = queue.poll();
			res.add(poll);
			count++;
            //删除以它为弧尾的边
			for(int j=h[poll];j!=-1;j=ne[j]) {
				if((--in[e[j]])==0) {
					queue.offer(e[j]);
				}
			}
		}
		if(count==n) {
			res.forEach(i->System.out.print(i+" "));
		}else {
			System.out.println(-1);
		}
		
	}//main
	private static void Add(int x, int y) {
		e[idx] = y;
		ne[idx] = h[x];
		h[x] = idx++;
	}
}
```



### 6、关键路径

AOE网







### 7.注意



图的初始化







## 三、小总结

树和图的存储有类似之处，

对于完全二叉树可以采用顺序存储，对于一般的二叉树可以双亲、孩子

对于孩子表示法，图和树都可以用，用y总法(前向星)。





对于需要遍历的图或者特别稀疏的图用前向星法，对于需要直接获取两点距离的、或者很稠密的(边多)用邻接矩阵

# 并查集

> 前言：
>
> 现在要做的是，给我们一个图，我们使用一种算法来判断图中是否存在一个环
>
> <img src="C:\Users\95266\AppData\Roaming\Typora\typora-user-images\image-20210308151816917.png" alt="image-20210308151816917" style="zoom:67%;" />



因此下面我们来介绍并查集算法

**Disjoint Set** 

作用：检查一个图上面是否存在一个环。



思路： 把图中所有的边过一遍（for循环）。把有连接的两个点放入一个集合中，

通过边(0,1) (1,2)

<img src="C:\Users\95266\AppData\Roaming\Typora\typora-user-images\image-20210308152114509.png" alt="image-20210308152114509" style="zoom: 33%;" />

通过边(0,1) (1,2) (3,4)我们得到集合

<img src="C:\Users\95266\AppData\Roaming\Typora\typora-user-images\image-20210308152355645.png" alt="image-20210308152355645" style="zoom:33%;" />



通过边(0,1) (1,2) (1,3) (3,4)我们得到了集合

<img src="C:\Users\95266\AppData\Roaming\Typora\typora-user-images\image-20210308152501162.png" alt="image-20210308152501162" style="zoom:33%;" />

**一个集合中（红圈）所有的节点，都相互有路径可有到达彼此。另外我们可以发现，不谈已访问过的边，也即其余的边(非红色)上如果有两点，在同一个集合中，则一定有环！**



以上是自然语言分析，那么该如何使用数据结构代码表示出来呢

难点是：如何把两个集合合并，**方法是：用一个一维数组(双亲表示法)表示一个树结构，用这个树去代表一个集合。集合的合并就变成树的合并了。**

<img src="C:\Users\95266\AppData\Roaming\Typora\typora-user-images\image-20210308153745484.png" alt="image-20210308153745484" style="zoom:53%;" />

**parent[i]=value 代表 第i个结点的双亲是value结点**   ，value=-1代表没有父结点（初始化）。

这样的话，当遍历了(0,1) (1,2) (3,4)之后，数组就变成了这样

<img src="C:\Users\95266\AppData\Roaming\Typora\typora-user-images\image-20210308154711909.png" alt="image-20210308154711909" style="zoom:50%;" />

再遇到边(1,3)时 ，我们要把 这两个树 合并了。注意不是随意的合并，比如 2,3  或者1,3就不是一个好的选择，因为会造成断层（多个根节点）或者链过长。因此我们要做的是：**把所有父节点连在一起，（新的树只有一个父节点）**。**因此我们合并两颗树的具体做法是：找到根，然后判断根是否是同一个，是的话就找到环了！！否的话就合并根节点。**

<img src="C:\Users\95266\AppData\Roaming\Typora\typora-user-images\image-20210308155053076.png" alt="image-20210308155053076" style="zoom:50%;" />

下面我们遇到边(2,4)。我们要做的是 找到findroot(2 和findroot(4)。发现他们是一个root，则说明两个点在同一个集合里，则检测出环！！！

> **我的理解：**并查集是一种检测图中环的算法，具体做法是：
>
>**预备动作**：构造出parent数组，用来表示(双亲表示法)树结构。
> 
>**开始前：**此时，所有结点都是独立的，parent全-1
> **正式动作：**遍历每一条边，union两个顶点，若findroot（这两个顶点）发现是同一个root，则union失败，说明找到环了，若不是同一个root，则将这两个root结点合并（也即合并两个集合）
> 
>
> 
>上述过程中的关键函数是findroot 和union
> 
>1.find_root(x)
> 
>2.union(x,y)：

java实现（因为要遍历每条边，因此建议采用**边集数组**）

```java
public class 模板尝试 {
	static int []parent=new int[10];
	public static void main(String[] args) {
		Arrays.fill(parent, -1);//初始化parent 树
		int [][]edges=new int[][] {//图
			{0,1},{1,2},{1,3},
//			{2,4},
			{3,4},{2,5},
		};
        //每条边走一遍！！！！
		for (int i = 0; i < 5; i++) {
			int x=edges[i][0];
			int y=edges[i][1];
			if(!union(x, y)) {
				System.out.println("Cycle detected!");
				return;
			}
		}
		System.out.println("No cycles");
	}//main
	
	
	/*
	  union函数， 作用是把 x y节点代表的集合合并起来 。
	  false 说明合并失败，发现环了！  true说明合并成功
	 */
	static boolean union(int x, int y) {
		int root_x = find_root(x);
		int root_y = find_root(y);
		if(root_x == root_y)
			return false;
		else {
			parent[root_x] = root_y; //注意，此步有点随意
			return true;
		}
	}

	static int find_root(int x) {
		int root_x=x;
		while(parent[root_x]!=-1) {
			root_x=parent[root_x];
		}
		return root_x;
	}
}

```

注意上面合并的代码 `parent[root_x]=root_y; `有点随意，我们要改进它，否则生成的树可能链很长，影响find_root效率



## 代码

**优化-压缩路径**

让树的高度尽可能的小，思路是比较待合并的两树的高度rank，比如x 树和y树（x为根节点，y为根节点的树代表集合）。 如果rank[x]>rank[y] 那么就parent[y]=x。因为小的树并到大的树上时，Rank不变！

rank数组的含义就是 rank[i] = value  代表i为根节点，i树的高度

```java
public class 模板尝试 {
	static int []parent=new int[10];
	static int []rank=new int[10];
	public static void main(String[] args) {
		Arrays.fill(parent, -1);//初始化parent 树
		Arrays.fill(rank, 0);//初始化rank数组
		int [][]edges=new int[][] {//图
			{0,1},
			{1,2},
			{1,3},
			{2,4},
			{3,4},
			{2,5},
		};
		for (int i = 0; i < 6; i++) {//每一次for循环，就把x和y所代表的的集合合并了(树的根节点合并了)
			int x = edges[i][0];
			int y = edges[i][1];
			if(!union(x, y)) {
				System.out.println("Cycle detected!");
				return;
			}
		}
		System.out.println("No cycles");
	}//main
	
	
	/*
	  union函数， 作用是把 x y节点代表的集合合并起来 。
	  false 说明合并失败，发现环了！  true说明合并成功
	 */
	static boolean union(int x, int y) {
		int root_x = find_root(x);
		int root_y = find_root(y);
		if(root_x==root_y)
			return false;
		else {
//			parent[root_x]=root_y; 代替此步
			if(rank[root_x]>rank[root_y]) {
				parent[root_y]=root_x;
			}
			else if(rank[root_x]<rank[root_y]) {
				parent[root_x]=root_y;
			}else {
				parent[x]=y;
				rank[root_y]++;
			}
			return true;
		}
	}

	static int find_root(int x) {
		int temp=x;
		while(parent[temp]!=-1) {
			temp=parent[temp];
		}
		return temp;
	}
}
```

> **总结：**
>
> 并查集算法执行完就获得了一个个不互相连通的集合
>
> 并查集是判断图中是否有环的算法，方法是：
>
> 首先先做好预备工作：准备图中结点数量长度的parent数组和rank数组，分别用以表示树和用来压缩路径。此时，所有结点都是独立的，parent全-1。
>
> 然后正式工作：遍历图中每一条边，取出两端点x,y合并其所在的集合(调用union函数)。在union函数内部，
> 如果find_root(x)!=find_root(y)，则合并之。合并的方法注意优化
> 如果find_root(x)==find_root(y)，已属于一个集合，则成功找到环！



>  **应用：**
>
>  一、通过并查集算法，当遍历所有的边，完全填充了parent数组之后，得到的这个数据结构很牛逼，可以用来1.求图的连通分量个数(找parent -1的数量)。2.任给两点求是否连通(是否为同一个根)
>
>  二、判断图中是否有环









## leetcode题目

[1202. 交换字符串中的元素](https://leetcode-cn.com/problems/smallest-string-with-swaps/)

题意：给定一个字符串 str,和一个pair数组。pair存放的是两个索引，代表可以交换位置，求str交换后最小的字典序排列

通过对示例的分析，我们知道，当前问题是一个图论的问题，我们需要找出同属于一个连通分量的所有字符。把「连在一起」的索引按照字符的 ASCII 值升序排序。交换关系具有传递性、找哪些索引连在一起、数组 `pairs` 给出的是数对的形式，这三点提示我们可以使用并查集。

```java
class Solution {
public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {
    if(pairs.size()==0) return s;
    	DisjointSet djs = new DisjointSet(s.length());
    	for (List<Integer> list : pairs) {
			int x=list.get(0);
			int y=list.get(1);
			djs.Union(x, y);
		}
    	
    	//得到树之后，建立一个 (根index,字符优先队列) 的HashMap
    	//然后for index, find root ,get(root).append(poll)
    	HashMap<Integer, PriorityQueue<Character>> hm = new HashMap<Integer,PriorityQueue<Character>>();
    	char[] charArray = s.toCharArray();
    	int m = s.length();
    	for(int i=0;i<m;i++) {
    		int root_i = djs.find_root(i);
    		if(hm.containsKey(root_i)) {
    			hm.get(root_i).offer(charArray[i]);
    		}
    		else {
    			PriorityQueue<Character> pq = new PriorityQueue<Character>();
    			pq.offer(charArray[i]);
				hm.put(root_i, pq);
			}
    	}
    	
    	StringBuilder sb = new StringBuilder();
    	for(int i=0;i<m;i++) {
    		sb.append(hm.get(djs.find_root(i)).poll());
    	}
    	
    	
    	
    	return sb.toString();
    }
}
class DisjointSet{
    int[] parent;
    int[] rank;
    int n;
    public DisjointSet(int n) {
    	this.n=n;
    	parent=new int[n];
    	rank=new int[n];
    	Arrays.fill(parent, -1);
	}
    
    public boolean Union(int x,int y) {
    	int root_x=find_root(x);
    	int root_y=find_root(y);
    	//同根，说明在一个树中不用合并了
    	if(root_x==root_y) return false;
    	//不同根，说明不在一个树上，不在一个集合里，需要合并
    	if(rank[root_x]>rank[root_y]) {
    		parent[root_y]=root_x;
    	}else if (rank[root_y]>rank[root_x]) {
			parent[root_x]=root_y;
		}else {
			parent[root_x]=root_y;
			rank[root_y]++;
		}
    	
    	return true;
    }

	public int find_root(int x) {
		int temp=x;
		while(parent[temp]!=-1) {
			temp=parent[temp];
		}
		return temp;
	}
}
```









# 线段树

**已废弃！请参考Awing高级课**

Segment Tree



>  背景：有一个数组arr[ ]  , 对于arr[] 我们有很多次的两个操作：①、QuerySum(L,R)    ②、Update(idx, value) ，我们容易得其时间复杂度分别为O(n)和 O(1)，而使用PreSum时间复杂度是 O(1)和O(n)。而使用Segment Tree 的话时间复杂度都降为了O(logn)





线段树采用的存储结构是二叉树的顺序存储，也即开一个tree数组。如果我们下标从0开始的话，那么我们有
$$
对于节点node(指的是index)如果从0开始的话：\\
\begin{cases}
left\_node=node*2+1\\
right\_node=node*2+2\\ 
parent\_node=(node-1)/2
\end{cases}
$$



<img src="C:\Users\95266\AppData\Roaming\Typora\typora-user-images\image-20210404103336788.png" alt="image-20210404103336788" style="zoom: 67%;" />

<img src="C:\Users\95266\AppData\Roaming\Typora\typora-user-images\image-20210404103510205.png" alt="image-20210404103510205" style="zoom: 67%;" />



可以观察到：叶子结点就是我们的arr数组里的元素。  **也即：一个结点代表的是一个区间的和**

那么对于arr ，Segment Tree总共有多少个结点呢？



**编程实现：**

我们为了方便 规定关于tree数组的下标统一定义成node、 left_node 、 right_node
而对于原始数组arr的下标我们不加node，也即 start 、end、L、R














# 链表操作

原则：  要被删除的东西， 先奉献了再死

插入某个结点时，（旁边的）能赋的先赋上。   

删除某个结点时，（待删除的）能给的先给了。